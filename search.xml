<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【已解决】Python Pickle dump 报错]]></title>
      <url>/2019/01/12/python-pickle-dump-os-error/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Python代码中使用Pickle模块dump一个对象，报错：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   pickle.dump(self, f)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">OSError: [Errno <span class="number">22</span>] Invalid argument</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>相关环境参数：</p>
<ul>
<li>操作系统：macOS 10.13.4</li>
<li>Python版本：Python 3.6.3</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>出现该问题的原因是Pickle的对象太大，超过了2G，在OSX系统中无法直接dump，需要借助bytearray进行文件写入，如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">"pkl.pkl"</span></span><br><span class="line">n_bytes = <span class="number">2</span>**<span class="number">31</span></span><br><span class="line">max_bytes = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">data = bytearray(n_bytes)</span><br><span class="line"></span><br><span class="line"><span class="comment">## write</span></span><br><span class="line">bytes_out = pickle.dumps(data)</span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, len(bytes_out), max_bytes):</span><br><span class="line">        f_out.write(bytes_out[idx:idx+max_bytes])</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/31468117/python-3-can-pickle-handle-byte-objects-larger-than-4gb" target="_blank" rel="noopener">https://stackoverflow.com/questions/31468117/python-3-can-pickle-handle-byte-objects-larger-than-4gb</a><br><a href="https://bugs.python.org/issue24658" target="_blank" rel="noopener">https://bugs.python.org/issue24658</a><br><a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pickle.html</a></p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2019-01-12</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在XGBoost中通过Early Stop避免过拟合]]></title>
      <url>/2018/12/15/early-stop-in-xgboost/</url>
      <content type="html"><![CDATA[<p>本文翻译自<a href="https://machinelearningmastery.com/avoid-overfitting-by-early-stopping-with-xgboost-in-python/" target="_blank" rel="noopener">Avoid Overfitting By Early Stopping With XGBoost In Python</a>，讲述如何在使用XGBoost建模时通过Early Stop手段来避免过拟合。全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。以下为全文内容：</p>
<p>过拟合问题是在使用复杂的非线性学习算法时会经常碰到，比如gradient boosting算法。</p>
<p>在这篇博客中你将发现如何通过Early Stop方法使得我们在使用Python中的XGBoost模型时可以尽可能地避免过拟合问题。</p>
<p>读完这篇博客后，你将学到：</p>
<ul>
<li>Early Stop可以减少训练集上的过拟合</li>
<li>在使用XGBoost模型时如何监控训练过程中模型的表现，如何绘制学习曲线</li>
<li>如何使用Early Stop方法在模型表现最好的时候停止训练</li>
</ul>
<p>让我们开始吧。</p>
<a id="more"></a>
<h2 id="使用Early-Stop避免过拟合"><a href="#使用Early-Stop避免过拟合" class="headerlink" title="使用Early Stop避免过拟合"></a>使用Early Stop避免过拟合</h2><p>Early Stop是训练复杂机器学习模型以避免其过拟合的一种方法。</p>
<p>它通过监控模型在一个额外的测试集上的表现来工作，当模型在测试集上的表现在连续的若干次（提前指定好的）迭代中都不再提升时它将终止训练过程。</p>
<p>它通过尝试自动选择拐点来避免过拟合，在拐点处，测试数据集的性能开始下降，而训练数据集的性能随着模型开始过拟合而继续改善。</p>
<p>性能的度量可以是训练模型时正在使用的损失函数（例如对数损失），或通常意义上用户感兴趣的外部度量（例如分类精度）。</p>
<h2 id="在XGBoost中监控模型的表现"><a href="#在XGBoost中监控模型的表现" class="headerlink" title="在XGBoost中监控模型的表现"></a>在XGBoost中监控模型的表现</h2><p>XGBoost模型在训练时可以计算并输入在某个指定的测试数据集的性能表现。</p>
<p>在调用<code>model.fit()</code>函数时，可以指定测试数据集和评价指标，同时设置<code>verbose</code>参数为<code>True</code>，这样就可以在训练过程中输出模型在测试集的表现。</p>
<p>例如，我们可以通过下面的方法在使用XGBoost训练二分类任务时输出分类错误率（通过“error”指定）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval_set = [(X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, eval_metric=<span class="string">"error"</span>, eval_set=eval_set, verbose=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>XGBoost提供了一系列的模型评价指标，包括但不限于：</p>
<ul>
<li>“rmse” 代表均方根误差</li>
<li>“mae” 代表平均绝对误差</li>
<li>“logloss” 代表二元对数损失</li>
<li>“mlogloss” 代表m-元对数损失</li>
<li>“error” 代表分类错误率</li>
<li>“auc” 代表ROC曲线下面积</li>
</ul>
<p>完整的列表见XGBoost文档中的<a href="https://xgboost.readthedocs.io/en/latest//parameter.html" target="_blank" rel="noopener">“Learning Task Parameters””</a>章节。</p>
<p>例如，我们可以演示如何监控使用UCI机器学习存储库（<a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv" target="_blank" rel="noopener">更新：从这里下载</a>）的关于Pima糖尿病发病数据集的XGBoost模型在训练过程中的性能指标。</p>
<p>完整代码清单如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># monitor training performance</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> loadtxt</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="comment"># load data</span></span><br><span class="line">dataset = loadtxt(<span class="string">'pima-indians-diabetes.csv'</span>, delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># split data into X and y</span></span><br><span class="line">X = dataset[:,<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">Y = dataset[:,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># split data into train and test sets</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=<span class="number">0.33</span>, random_state=<span class="number">7</span>)</span><br><span class="line"><span class="comment"># fit model no training data</span></span><br><span class="line">model = XGBClassifier()</span><br><span class="line">eval_set = [(X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, eval_metric=<span class="string">"error"</span>, eval_set=eval_set, verbose=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># make predictions for test data</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line">predictions = [round(value) <span class="keyword">for</span> value <span class="keyword">in</span> y_pred]</span><br><span class="line"><span class="comment"># evaluate predictions</span></span><br><span class="line">accuracy = accuracy_score(y_test, predictions)</span><br><span class="line">print(<span class="string">"Accuracy: %.2f%%"</span> % (accuracy * <span class="number">100.0</span>))</span><br></pre></td></tr></table></figure>
<p>运行这段代码将会在67%的数据集上训练模型，并且在每一轮迭代中使用剩下的33%数据来评估模型的性能。</p>
<p>每次迭代都会输出分类错误，最终将会输出最后的分类准确率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[89]	validation_0-error:0.204724</span><br><span class="line">[90]	validation_0-error:0.208661</span><br><span class="line">[91]	validation_0-error:0.208661</span><br><span class="line">[92]	validation_0-error:0.208661</span><br><span class="line">[93]	validation_0-error:0.208661</span><br><span class="line">[94]	validation_0-error:0.208661</span><br><span class="line">[95]	validation_0-error:0.212598</span><br><span class="line">[96]	validation_0-error:0.204724</span><br><span class="line">[97]	validation_0-error:0.212598</span><br><span class="line">[98]	validation_0-error:0.216535</span><br><span class="line">[99]	validation_0-error:0.220472</span><br><span class="line">Accuracy: 77.95%</span><br></pre></td></tr></table></figure>
<p>观察所有的输出，我们可以看到，在训练快要结束时测试集上的模型性能的变化是平缓的，甚至变得更差。</p>
<h2 id="使用学习曲线来评估XGBoost模型"><a href="#使用学习曲线来评估XGBoost模型" class="headerlink" title="使用学习曲线来评估XGBoost模型"></a>使用学习曲线来评估XGBoost模型</h2><p>我们可以提取出模型在测试数据集上的表现并绘制成图案，从而更好地洞察到在整个训练过程中学习曲线是如何变化的。</p>
<p>在调用XGBoost模型时我们提供了一个数组，数组的每一项是一个X和y的配对。在测试集之外，我们同时将训练集也作为输入，从而观察在训练过程中模型在训练集和测试集上各自的表现。</p>
<p>例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval_set = [(X_train, y_train), (X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, eval_metric=<span class="string">"error"</span>, eval_set=eval_set, verbose=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>模型在各个数据集上的表现可以在训练结束后通过<code>model.evals_result()</code>函数获取，这个函数返回一个<code>dict</code>包含了评估数据集的代码和对应的分数列表，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results = model.evals_result()</span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure>
<p>这将输出如下的结果：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">'validation_0'</span>: &#123;<span class="string">'error'</span>: [<span class="number">0.259843</span>, <span class="number">0.26378</span>, <span class="number">0.26378</span>, ...]&#125;,</span><br><span class="line">	<span class="string">'validation_1'</span>: &#123;<span class="string">'error'</span>: [<span class="number">0.22179</span>, <span class="number">0.202335</span>, <span class="number">0.196498</span>, ...]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“validation_0”和“validation_1”代表了在调用<code>fit()</code>函数时传给<code>eval_set</code>参数的数组中数据集的顺序。</p>
<p>一个特定的结果，比如第一个数据集上的分类错误率，可以通过如下方法获取：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results[<span class="string">'validation_0'</span>][<span class="string">'error'</span>]</span><br></pre></td></tr></table></figure>
<p>另外我们可以指定更多的评价指标，从而同时获取多种评价指标的变化情况。</p>
<p>接着我们可以使用收集到的数据绘制曲线，从而更直观地了解在整个训练过程中模型在训练集和测试集上的表现究竟如何。</p>
<p>下面是一段完整的代码，展示了如何将收集到的数据绘制成学习曲线：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot learning curve</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> loadtxt</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="comment"># load data</span></span><br><span class="line">dataset = loadtxt(<span class="string">'pima-indians-diabetes.csv'</span>, delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># split data into X and y</span></span><br><span class="line">X = dataset[:,<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">Y = dataset[:,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># split data into train and test sets</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=<span class="number">0.33</span>, random_state=<span class="number">7</span>)</span><br><span class="line"><span class="comment"># fit model no training data</span></span><br><span class="line">model = XGBClassifier()</span><br><span class="line">eval_set = [(X_train, y_train), (X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, eval_metric=[<span class="string">"error"</span>, <span class="string">"logloss"</span>], eval_set=eval_set, verbose=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># make predictions for test data</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line">predictions = [round(value) <span class="keyword">for</span> value <span class="keyword">in</span> y_pred]</span><br><span class="line"><span class="comment"># evaluate predictions</span></span><br><span class="line">accuracy = accuracy_score(y_test, predictions)</span><br><span class="line">print(<span class="string">"Accuracy: %.2f%%"</span> % (accuracy * <span class="number">100.0</span>))</span><br><span class="line"><span class="comment"># retrieve performance metrics</span></span><br><span class="line">results = model.evals_result()</span><br><span class="line">epochs = len(results[<span class="string">'validation_0'</span>][<span class="string">'error'</span>])</span><br><span class="line">x_axis = range(<span class="number">0</span>, epochs)</span><br><span class="line"><span class="comment"># plot log loss</span></span><br><span class="line">fig, ax = pyplot.subplots()</span><br><span class="line">ax.plot(x_axis, results[<span class="string">'validation_0'</span>][<span class="string">'logloss'</span>], label=<span class="string">'Train'</span>)</span><br><span class="line">ax.plot(x_axis, results[<span class="string">'validation_1'</span>][<span class="string">'logloss'</span>], label=<span class="string">'Test'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">pyplot.ylabel(<span class="string">'Log Loss'</span>)</span><br><span class="line">pyplot.title(<span class="string">'XGBoost Log Loss'</span>)</span><br><span class="line">pyplot.show()</span><br><span class="line"><span class="comment"># plot classification error</span></span><br><span class="line">fig, ax = pyplot.subplots()</span><br><span class="line">ax.plot(x_axis, results[<span class="string">'validation_0'</span>][<span class="string">'error'</span>], label=<span class="string">'Train'</span>)</span><br><span class="line">ax.plot(x_axis, results[<span class="string">'validation_1'</span>][<span class="string">'error'</span>], label=<span class="string">'Test'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">pyplot.ylabel(<span class="string">'Classification Error'</span>)</span><br><span class="line">pyplot.title(<span class="string">'XGBoost Classification Error'</span>)</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
<p>运行这段代码将会在每一次训练迭代中输出模型在训练集和测试集上的分类错误率。我们可以通过设置<code>verbose=False</code>来关闭输出。</p>
<p>我们绘制了两张图，第一张图表示的是模型在每一轮迭代中在两个数据集上的对数损失：</p>
<p><img src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2016/07/XGBoost-Learning-Curve-Log-Loss.png" alt="XGBoost Learning Curve Log Loss"></p>
<p>第二张图表示分类错误率：</p>
<p><img src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2016/07/XGBoost-Learning-Curve-Classification-Error.png" alt="XGBoost Learning Curve Classification Error"></p>
<p>从第一张图来看，似乎有机会可以进行Early Stop，大约在20到40轮迭代时比较合适。</p>
<p>从第二张图可以得到相似的结果，大概在40轮迭代时效果比较理想。</p>
<h2 id="在XGBoost中进行Early-Stop"><a href="#在XGBoost中进行Early-Stop" class="headerlink" title="在XGBoost中进行Early Stop"></a>在XGBoost中进行Early Stop</h2><p>XGBoost提供了在指定轮数完成后提前停止训练的功能。</p>
<p>除了提供用于评估每轮迭代中的评价指标和数据集之外，还需要指定一个窗口大小，意味着连续这么多轮迭代中模型的效果没有提升。这是通过<code>early_stopping_rounds</code>参数来设置的。</p>
<p>例如，我们可以像下面这样设置连续10轮中对数损失都没有提升：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval_set = [(X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, early_stopping_rounds=<span class="number">10</span>, eval_metric=<span class="string">"logloss"</span>, eval_set=eval_set, verbose=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>如果同时指定了多个评估数据集和多个评价指标，<code>early_stopping_rounds</code>将会使用数组中的最后一个作为依据。</p>
<p>下面提供了一个使用<code>early_stopping_rounds</code>的详细例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># early stopping</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> loadtxt</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="comment"># load data</span></span><br><span class="line">dataset = loadtxt(<span class="string">'pima-indians-diabetes.csv'</span>, delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># split data into X and y</span></span><br><span class="line">X = dataset[:,<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">Y = dataset[:,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># split data into train and test sets</span></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">test_size = <span class="number">0.33</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=test_size, random_state=seed)</span><br><span class="line"><span class="comment"># fit model no training data</span></span><br><span class="line">model = XGBClassifier()</span><br><span class="line">eval_set = [(X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, early_stopping_rounds=<span class="number">10</span>, eval_metric=<span class="string">"logloss"</span>, eval_set=eval_set, verbose=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># make predictions for test data</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line">predictions = [round(value) <span class="keyword">for</span> value <span class="keyword">in</span> y_pred]</span><br><span class="line"><span class="comment"># evaluate predictions</span></span><br><span class="line">accuracy = accuracy_score(y_test, predictions)</span><br><span class="line">print(<span class="string">"Accuracy: %.2f%%"</span> % (accuracy * <span class="number">100.0</span>))</span><br></pre></td></tr></table></figure>
<p>运行这段代码将得到如下的输出（部分）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[35]	validation_0-logloss:0.487962</span><br><span class="line">[36]	validation_0-logloss:0.488218</span><br><span class="line">[37]	validation_0-logloss:0.489582</span><br><span class="line">[38]	validation_0-logloss:0.489334</span><br><span class="line">[39]	validation_0-logloss:0.490969</span><br><span class="line">[40]	validation_0-logloss:0.48978</span><br><span class="line">[41]	validation_0-logloss:0.490704</span><br><span class="line">[42]	validation_0-logloss:0.492369</span><br><span class="line">Stopping. Best iteration:</span><br><span class="line">[32]	validation_0-logloss:0.487297</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到模型在迭代到42轮时停止了训练，在32轮迭代后观察到了最好的效果。</p>
<p>通常将<code>early_stopping_rounds</code>设置为一个与总训练轮数相关的函数（本例中是10%），或者通过观察学习曲线来设置使得训练过程包含拐点，这两种方法都是不错的选择。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇博客中你发现了如何监控模型的表现以及怎么做Early Stop。</p>
<p>你学会了：</p>
<ul>
<li>使用Early Stop手段在模型过拟合之前停止训练</li>
<li>在使用XGBoost模型时如何监控模型的表现并绘制出模型的学习曲线</li>
<li>在训练XGBoost模型时如何设置Early Stop参数</li>
</ul>
<p>关于Early Stop或者这篇博客你还有什么想问的问题吗？欢迎在下方的评论区留言，我将尽我最大的努力来解答。</p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-12-15</p>
]]></content>
      
        
        <tags>
            
            <tag> XGBoost </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker容器的时区设置]]></title>
      <url>/2018/10/28/docker-set-timezone/</url>
      <content type="html"><![CDATA[<p>Docker作为一款优秀的开源容器管理工具，能够帮助开发者一键式地在各个平台上运行自己的应用而无需考虑环境兼容问题，已经成为目前主流的应用部署方案。</p>
<p>在使用Docker容器时，可能碰到的一个问题是时区的设置，因为Docker容器内默认的时区是UTC，这一点可以通过<code>date</code>命令来验证。分别在宿主机和Docker容器内运行<code>date</code>命令，观察两者的输出是否相同</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">2018年10月29日 星期一 08时47分17秒 CST</span><br><span class="line">$ docker run -it ubuntu /bin/bash</span><br><span class="line">root@367851bfa10f:/<span class="comment"># date</span></span><br><span class="line">Mon Oct 29 00:48:09 UTC 2018</span><br></pre></td></tr></table></figure>
<p>可以看到，宿主机使用的是UTC+8时间，而Docker容器内使用的是UTC时间。大多数应用开发者通常希望使用UTC+8时间，因此我们需要在Docker中重新设置时区。以ubuntu镜像为例，我们可以通过如下的<code>Dockerfile</code>来完成时区的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN export DEBIAN_FRONTEND=noninteractive</span><br><span class="line">RUN apt-get install -y tzdata=2018d-1</span><br><span class="line">RUN ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </span><br><span class="line">RUN dpkg-reconfigure -f noninteractive tzdata</span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD . /app</span><br></pre></td></tr></table></figure>
<p>大体来说就是，我们需要在ubuntu镜像中安装<code>tzdate</code>软件包，然后进行软链接，再重新执行时区的设置。值得注意的是，在设置时区时只有<code>Asia/Shanghai</code>的选项而没有<code>Asia/Beijing</code>的选项，所以这里不要想当然地写错了。我们可以通过<code>docker build</code>命令生成对应的镜像，运行该镜像以观察效果。新建一个文件夹，将这个<code>Dockerfile</code>移到该文件夹下，然后执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t timezone:v1 .</span><br><span class="line">...</span><br><span class="line">Successfully built 0262dcc4daa5</span><br><span class="line">Successfully tagged timezone:v1</span><br><span class="line">$ docker run -it timezone:v1 /bin/bash</span><br><span class="line">root@11eb9259d038:/app<span class="comment"># date</span></span><br><span class="line">Mon Oct 29 09:05:44 CST 2018</span><br></pre></td></tr></table></figure>
<p>可以看到，Docker镜像中的时区修改为了UTC+8时间，大功告成！</p>
<p>参考链接：<a href="https://stackoverflow.com/questions/44331836/apt-get-install-tzdata-noninteractive" target="_blank" rel="noopener">https://stackoverflow.com/questions/44331836/apt-get-install-tzdata-noninteractive</a></p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-10-29</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《计算机是怎样跑起来的》阅读笔记]]></title>
      <url>/2018/09/20/how-computer-running-notes/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>其实不仅是计算机，其他学问亦是如此。首先要划出一个“知识的范围”，精通一门学问所必知必会的知识都在这个范围内。其次是掌握该范围内每个知识点中“基础中的基础知识”。最后是能独当一面的“目标”，即掌握了这些知识可以做什么。</li>
</ul>
<a id="more"></a>
<h2 id="第1章-计算机的三大原则"><a href="#第1章-计算机的三大原则" class="headerlink" title="第1章 计算机的三大原则"></a>第1章 计算机的三大原则</h2><h3 id="1-3-软件是指令和数据的集合"><a href="#1-3-软件是指令和数据的集合" class="headerlink" title="1.3 软件是指令和数据的集合"></a>1.3 软件是指令和数据的集合</h3><ul>
<li>无论是哪个程序，其内容都是数值的罗列，每个数值要么是指令，要么是数据。</li>
</ul>
<h3 id="1-5-只要理解了三大原则，即使遇到难懂的最新技术，也能轻松应对"><a href="#1-5-只要理解了三大原则，即使遇到难懂的最新技术，也能轻松应对" class="headerlink" title="1.5 只要理解了三大原则，即使遇到难懂的最新技术，也能轻松应对"></a>1.5 只要理解了三大原则，即使遇到难懂的最新技术，也能轻松应对</h3><ul>
<li>所谓计算机的协同工作指的是，输入到一台计算机中的数据，可以通过互联网传送到与这台计算机相连的其他计算机上执行运算，运算所输出的结果再返回给这台计算机。像这样部署在其他计算机上能执行某种运算的程序就叫作XML Web服务。</li>
</ul>
<h2 id="第3章-体验一次手工汇编"><a href="#第3章-体验一次手工汇编" class="headerlink" title="第3章 体验一次手工汇编"></a>第3章 体验一次手工汇编</h2><h3 id="3-1-从程序员的角度看硬件"><a href="#3-1-从程序员的角度看硬件" class="headerlink" title="3.1 从程序员的角度看硬件"></a>3.1 从程序员的角度看硬件</h3><ul>
<li><p>然而真正需要了解的硬件信息只有以下7种（如图3.1所示），所以没有必要在编程时还总是盯着详细的电路图看。</p>
</li>
<li><p>即便是相同的机器语言，例如01010011，只要CPU的种类不同，对它的解释也就不同。</p>
</li>
</ul>
<h3 id="3-3-Z80-CPU的寄存器结构"><a href="#3-3-Z80-CPU的寄存器结构" class="headerlink" title="3.3 Z80 CPU的寄存器结构"></a>3.3 Z80 CPU的寄存器结构</h3><ul>
<li><p>既然数据的运算是在CPU中进行的，那么在CPU内部就应该有存储数据的地方。这种存储数据的地方叫作“寄存器”。</p>
</li>
<li><p>PC寄存器也叫作“程序指针”，存储着指向CPU接下来要执行的指令的地址。PC寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的PC寄存器的值运行起来的。</p>
</li>
</ul>
<h2 id="第4章-程序像河水一样流动着"><a href="#第4章-程序像河水一样流动着" class="headerlink" title="第4章 程序像河水一样流动着"></a>第4章 程序像河水一样流动着</h2><h3 id="4-4-结构化程序设计"><a href="#4-4-结构化程序设计" class="headerlink" title="4.4 结构化程序设计"></a>4.4 结构化程序设计</h3><ul>
<li><p>简单地说，所谓结构化程序设计就是“为了把程序编写得具备结构性，仅使用顺序执行、条件分支和循环表示程序的流程即可，而不再使用跳转指令”。</p>
</li>
<li><p>但是即使使用了结构化异常处理，在硬件上使用的也还是跳转指令，只是说在高级语言中不用再写相当于跳转指令的语句了。如果把用高级语言所编写的程序转换成机器语言，像结构化异常处理这样的语句还是会被转换为跳转指令。</p>
</li>
</ul>
<h3 id="4-5-画流程图来思考算法"><a href="#4-5-画流程图来思考算法" class="headerlink" title="4.5 画流程图来思考算法"></a>4.5 画流程图来思考算法</h3><ul>
<li>所谓算法（Algorithm），就是解决既定问题的步骤。想让计算机解决问题，就需要把问题的解法转换成程序的流程。</li>
</ul>
<h3 id="4-6-特殊的程序流程——中断处理"><a href="#4-6-特殊的程序流程——中断处理" class="headerlink" title="4.6 特殊的程序流程——中断处理"></a>4.6 特殊的程序流程——中断处理</h3><ul>
<li>像这样由于外部的原因使正常的流程中断，中断后再返回到之前流程的过程就是中断处理流程。</li>
</ul>
<h3 id="4-7-特殊的程序流程——事件驱动"><a href="#4-7-特殊的程序流程——事件驱动" class="headerlink" title="4.7 特殊的程序流程——事件驱动"></a>4.7 特殊的程序流程——事件驱动</h3><ul>
<li>通常把用户在应用程序中点击鼠标或者敲击键盘这样的操作称作“事件”（Event）。负责检测事件的是Windows。Windows通过调用应用程序的WndProc()函数通知应用程序事件的发生。而应用程序则根据事件的类型做出相应的处理。这种机制就是事件驱动。可以说事件驱动也是一种特殊的条件分支，它以从Windows送来的通知为条件，根据通知的内容决定程序下一步的流程。</li>
</ul>
<h2 id="第5章-与算法成为好朋友的七个要点"><a href="#第5章-与算法成为好朋友的七个要点" class="headerlink" title="第5章 与算法成为好朋友的七个要点"></a>第5章 与算法成为好朋友的七个要点</h2><h3 id="5-2-要点1：算法中解决问题的步骤是明确且有限的"><a href="#5-2-要点1：算法中解决问题的步骤是明确且有限的" class="headerlink" title="5.2 要点1：算法中解决问题的步骤是明确且有限的"></a>5.2 要点1：算法中解决问题的步骤是明确且有限的</h3><ul>
<li>而且请诸位注意这样一个条件，那就是“步骤必须是明确的并且步骤数必须是有限的”。</li>
</ul>
<h2 id="第7章-面向对象编程"><a href="#第7章-面向对象编程" class="headerlink" title="第7章 面向对象编程"></a>第7章 面向对象编程</h2><h3 id="7-8-观点6：面向对象编程通过在对象间传递消息驱动程序"><a href="#7-8-观点6：面向对象编程通过在对象间传递消息驱动程序" class="headerlink" title="7.8 观点6：面向对象编程通过在对象间传递消息驱动程序"></a>7.8 观点6：面向对象编程通过在对象间传递消息驱动程序</h3><ul>
<li>在时序图中，把用矩形表示的对象横向排列，从上往下表示时间的流逝，用箭头表示对象间的消息传递（即程序上的函数调用）。</li>
</ul>
<h2 id="第8章-数据库"><a href="#第8章-数据库" class="headerlink" title="第8章 数据库"></a>第8章 数据库</h2><h3 id="8-4-通过拆表和整理数据实现规范化"><a href="#8-4-通过拆表和整理数据实现规范化" class="headerlink" title="8.4 通过拆表和整理数据实现规范化"></a>8.4 通过拆表和整理数据实现规范化</h3><ul>
<li>规范化的要点是在一个数据库中要避免重复存储相同的数据。</li>
</ul>
<h3 id="8-5-用主键和外键在表间建立关系"><a href="#8-5-用主键和外键在表间建立关系" class="headerlink" title="8.5 用主键和外键在表间建立关系"></a>8.5 用主键和外键在表间建立关系</h3><ul>
<li>当出现多对多关系时，可以在这两张表之间再加入一张表，把多对多关系分解成两个一对多关系（如图8.10所示）。加入的这张表被称作连接表（Link Table）。</li>
</ul>
<h3 id="8-7-设计用户界面"><a href="#8-7-设计用户界面" class="headerlink" title="8.7 设计用户界面"></a>8.7 设计用户界面</h3><ul>
<li>只要通过拆表实现了规范化、设置了主键和外键、确保没有多对多关系、根据需要设置了参照完整性和索引，那么数据库的设计就告一段落了。</li>
</ul>
<h3 id="8-9-使用数据对象向DBMS发送SQL语句"><a href="#8-9-使用数据对象向DBMS发送SQL语句" class="headerlink" title="8.9 使用数据对象向DBMS发送SQL语句"></a>8.9 使用数据对象向DBMS发送SQL语句</h3><ul>
<li>在Windows应用程序中，向DBMS发送SQL语句时，一般情况下使用的都是被称为数据对象（Data Object）的软件组件（参考第7章所介绍的类）。</li>
</ul>
<h2 id="第9章-TCP-IP-协议"><a href="#第9章-TCP-IP-协议" class="headerlink" title="第9章 TCP/IP 协议"></a>第9章 TCP/IP 协议</h2><h3 id="9-2-实验1：查看网卡的MAC地址"><a href="#9-2-实验1：查看网卡的MAC地址" class="headerlink" title="9.2 实验1：查看网卡的MAC地址"></a>9.2 实验1：查看网卡的MAC地址</h3><ul>
<li><p>以太网中的每台计算机都需要先确认一件事：在网线上有没有其他的计算机正在传输电信号，也就是说要先确保没有人在占用网络，然后才能发送自己想传输的电信号。谁先抢到了网线的使用权，谁就先发送。万一遇到了多台计算机同时都想发送电信号的情况，只需要让这些计算机等待一段长度随机的时间后再重新发送相同的电信号即可。</p>
</li>
<li><p>在每一块网卡所带有的ROM（Read Only Memory，只读存储器）中，都预先烧录了一个唯一的MAC地址。网卡的制造厂商负责确定这个MAC地址是什么。因为MAC地址是由制造厂商的编号和产品编号两部分组成的，所以世界上的每一个MAC地址都是独一无二的。</p>
</li>
</ul>
<h3 id="9-3-实验2：查看计算机的IP地址"><a href="#9-3-实验2：查看计算机的IP地址" class="headerlink" title="9.3 实验2：查看计算机的IP地址"></a>9.3 实验2：查看计算机的IP地址</h3><ul>
<li><p>通常把设定了IP地址的计算机称为“主机”（Host）。因为路由器也算是计算机的一种，所以它们也有IP地址。在TCP/IP网络中，传输的数据都会携带MAC地址和IP地址两个地址。</p>
</li>
<li><p>子网掩码中，值为1的那些位对应着IP地址中的网络地址，后面值为0的那些位则对应着主机地址。因此255.255.255.240这个子网掩码就表示，其所对应的IP地址前28比特是网络地址，后4比特是主机地址。</p>
</li>
</ul>
<h3 id="9-5-实验4：路由器是数据传输过程中的指路人"><a href="#9-5-实验4：路由器是数据传输过程中的指路人" class="headerlink" title="9.5 实验4：路由器是数据传输过程中的指路人"></a>9.5 实验4：路由器是数据传输过程中的指路人</h3><ul>
<li>分布在世界各地的LAN中的路由器相互交换着信息，互联网正是由于这种信息的交换才得以联通。这种信息被称作“路由表”，用来记录应该把数据转发到哪里。</li>
</ul>
<h3 id="9-7-实验6-DNS服务器可以把主机名解析成IP地址"><a href="#9-7-实验6-DNS服务器可以把主机名解析成IP地址" class="headerlink" title="9.7 实验6:DNS服务器可以把主机名解析成IP地址"></a>9.7 实验6:DNS服务器可以把主机名解析成IP地址</h3><ul>
<li>诸位的计算机都有一个主机名，每个LAN也都有一个域名。举例来说，笔者所使用的计算机的主机名是ma50j（源于这台计算机的型号），所在的LAN的域名是yzw.co.jp。把主机名和域名组合起来所形成的ma50j.yze.co.jp，就是能够标识笔者这台计算机的一个世界范围内独一无二的名字，这个名字与IP地址的作用是等价的。通常把这种由主机名和域名组合起来形成的名字称作FQDN（Fully Qualified Domain Name，完整限定域名）。</li>
</ul>
<h2 id="第11章-XML究竟是什么"><a href="#第11章-XML究竟是什么" class="headerlink" title="第11章 XML究竟是什么"></a>第11章 XML究竟是什么</h2><ul>
<li>通常把用于定义新语言的语言称作元语言。通过使用XML可以定义出各种各样的新语言。</li>
</ul>
<h3 id="11-1-XML是标记语言"><a href="#11-1-XML是标记语言" class="headerlink" title="11.1 XML是标记语言"></a>11.1 XML是标记语言</h3><ul>
<li>通常把通过添加标签为数据赋予意义的行为称为“标记”。为这种给数据赋予意义的行为定义规则的语言就是“标记语言”。HTML是用于编写网页的标记语言，更简单地说法就是HTML决定了可用于编写网页的标签。</li>
</ul>
<h3 id="11-2-XML是可扩展的语言"><a href="#11-2-XML是可扩展的语言" class="headerlink" title="11.2 XML是可扩展的语言"></a>11.2 XML是可扩展的语言</h3><ul>
<li>XML本身并不会限定标签的种类，反倒是允许XML的使用者随心所欲地创建标签。也就是说，在“&lt;”和“&gt;”中的单词可以是任意的。这就是所谓的“可扩展”。</li>
</ul>
<h3 id="11-3-XML是元语言"><a href="#11-3-XML是元语言" class="headerlink" title="11.3 XML是元语言"></a>11.3 XML是元语言</h3><ul>
<li>XML并没有限定标签的使用方式，使用什么样的标签都可以。可以说XML仅仅限定了进行标记时标签的书写格式（书写风格）。也就是说通过定义要使用的标签种类，就可以创造出一门新的标记语言。通常把这种用于创造语言的语言称作“元语言”。</li>
</ul>
<h3 id="11-4-XML可以为信息赋予意义"><a href="#11-4-XML可以为信息赋予意义" class="headerlink" title="11.4 XML可以为信息赋予意义"></a>11.4 XML可以为信息赋予意义</h3><ul>
<li>也就是说，XML的主要用途是为在互联网上交换的信息赋予意义（如图11.9所示）。当然，在互联网以外的场景也可以使用XML。只不过在XML诞生的过程中互联网一直伴随其左右。</li>
</ul>
<h3 id="11-9-XML可用于各种各样的领域"><a href="#11-9-XML可用于各种各样的领域" class="headerlink" title="11.9 XML可用于各种各样的领域"></a>11.9 XML可用于各种各样的领域</h3><ul>
<li>SOAP（Simple Object Access Protocol，简单对象访问协议）可用于分布式计算。所谓分布式计算，就是把程序分散部署在用网络连接起来的多台计算机上，使这些计算机相互协作，充分发挥计算机整体的计算能力。简单地说，SOAP就是使运行在A公司计算机中的A程序，可以调用运行在B公司计算机中的B程序。</li>
</ul>
<h2 id="第12章-SE负责监管计算机系统的构建"><a href="#第12章-SE负责监管计算机系统的构建" class="headerlink" title="第12章 SE负责监管计算机系统的构建"></a>第12章 SE负责监管计算机系统的构建</h2><h3 id="12-3-系统开发过程的规范"><a href="#12-3-系统开发过程的规范" class="headerlink" title="12.3 系统开发过程的规范"></a>12.3 系统开发过程的规范</h3><ul>
<li>在瀑布模型中，每完成一个阶段，都要书写文档（报告）并进行审核。进行审核时还需要召开会议，在会上由SE为开发团队的成员、上司以及客户讲解文档的内容。若审核通过了，就可以从上司或客户那里得到批准，继续进入后续的开发阶段。若审核没有通过，则不能进入后续的阶段。一旦进入了后续的阶段，就不能回退到之前的阶段。为了避免回退到上一阶段，一是要力求完美地完成每一个阶段的工作，二是要彻底地执行审核过程，这些就是瀑布模型的特征。</li>
</ul>
<h3 id="12-7-技术能力和沟通能力"><a href="#12-7-技术能力和沟通能力" class="headerlink" title="12.7 技术能力和沟通能力"></a>12.7 技术能力和沟通能力</h3><ul>
<li>正如之前讲解的那样，SE所要具备的能力是多种多样的。这些能力大体上可以分为两类——技术能力（Technical Skill）和沟通能力（Communication Skill）。所谓技术能力，是指灵活运用硬件、软件、网络、数据库等技术的能力。而所谓沟通能力，是指和他人交换信息的能力，而且这里要求的是双向的信息交换能力。一个方向是从客户到SE，即SE倾听客户等的需求；另一个方向是从SE到客户，即SE向客户等人传达信息。</li>
</ul>
<h3 id="12-10-大幅提升设备利用率的多机备份"><a href="#12-10-大幅提升设备利用率的多机备份" class="headerlink" title="12.10 大幅提升设备利用率的多机备份"></a>12.10 大幅提升设备利用率的多机备份</h3><ul>
<li>专家也好普通人也罢，只有为社会做出了贡献才能有成就感，才会觉得工作有意义。可能有人会觉得“这么说来，即使是程序员，只要能意识到自己也是在为社会做贡献不就好了吗？”能这样想就对了！SE也好程序员也罢，所有和计算机相关的工程师都要有这样一种意识：我们要让计算机技术服务于社会。如果能有这样的决心，就应该能作为一生的事业和计算机愉快地相处下去了吧。</li>
</ul>
<h3 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h3><p>★★★☆☆<br>语言组织上通俗易懂是个亮点，但内容相对有点老旧，作为基础的入门材料可以看看。</p>
<h3 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h3><p>书名：计算机是怎样跑起来的<br>作者：[日]矢泽久雄<br>译者：胡屹<br>出版社：人民邮电出版社<br>出版时间：2015-05</p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-09-20</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> book </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《MySQL必知必会》学习笔记]]></title>
      <url>/2018/08/11/mysql-crash-course-note/</url>
      <content type="html"><![CDATA[<h2 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h2><ul>
<li><strong>数据库是一个以某种有组织的方式存储的数据集合。</strong></li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名，等等。<strong>描述表的这组信息就是所谓的模式</strong>，模式可以用来描述数据库中特定的表以及整个数据库(和其中表的关系)。</li>
</ul>
<a id="more"></a>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><ul>
<li><strong>如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义</strong>。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。</li>
<li><strong>在处理SQL语句时，其中所有空格都被忽略</strong>。SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。</li>
</ul>
<h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><ul>
<li><strong>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</strong></li>
</ul>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><ul>
<li><strong>MySQL在执行匹配时默认不区分大小写。</strong></li>
<li><strong>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处</strong>。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><strong>所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。</strong></li>
<li>LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回(除非使用通配符)。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。</li>
<li><strong>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配</strong>。为更方便工作，可以使用预定义的字符集，称为字符类。</li>
</ul>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><ul>
<li>SELECT提供了测试和试验函数与计算的一个很好的办法。<strong>虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单地访问和处理表达式。</strong></li>
</ul>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><ul>
<li><strong>在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。</strong></li>
<li><strong>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</strong></li>
</ul>
<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><ul>
<li>在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。<strong>MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行</strong>。这样，MySQL可以快速有效地决定哪些词匹配(哪些行包含它们)，哪些词不匹配，它们匹配的频率，等等。</li>
<li><strong>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。</strong></li>
</ul>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul>
<li><strong>如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 (错误发生前更新的所有行被恢复到它们原来的值)。为即使是发生错误，也继续进行更新，可使用IGNORE关键字。</strong></li>
</ul>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><ul>
<li>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。<strong>视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</strong></li>
</ul>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-08-11</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[交叉验证的原理与用法]]></title>
      <url>/2018/06/23/cross-validation-usage/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在机器学习中，交叉验证（cross validation）是一种用来做模型选择的方法。如果给定的样本数据充足，我们可以随机地将数据集切分成训练集、验证集和测试集，训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对方法进行评估。然而实际情况中数据往往是不够充分的，为了更好地选择模型，可以使用交叉验证的方法。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>具体而言，当我们开始一个机器学习的建模工作时，首先会将数据集切分成训练集和测试集，我们在训练集上进行模型的训练和参数的调优，最终到测试集上验证模型的效果。为了能够选择出最优的模型和参数，我们通常会在训练集中再切分出一小部分作为验证集，通过观察模型在验证集上的效果来评估其好坏。但是如果训练集的数目不太多，那么不同验证集的选择方式可能会对模型的效果有很大影响。因此，我们可以采用交叉验证的方式。最常用的是K-fold交叉验证法，我们随机的将训练集等分为K份，每次训练时取其中的一份作为验证集，剩下的作为训练集，通过观察模型在K次实验中的各个指标的平均值，可以对模型的效果有一个比较准确的了解，而不至于受到验证集选择方式的影响。我们可以设置不同的模型参数并逐一观察它们的平均效果，最终可以选择出一组最优的参数应用到测试集上。</p>
<h2 id="测试集的选择"><a href="#测试集的选择" class="headerlink" title="测试集的选择"></a>测试集的选择</h2><p>前面我们谈到了使用交叉验证来进行参数选择，其实对于测试集和训练集的切分也可以应用交叉验证的方法。当整个数据集较小时，如何选择合适的测试集也是个问题，在随机切分的情况下，我们可能刚好选择了一些相对容易预测的数据点作为测试集，这会使得我们模型的最终效果看起来很好，但这并不是真实的情况。为了避免这种因为测试集的选择方式所导致的模型效果出现波动的问题，我们也可以使用交叉验证的方式，通过观察模型在多个测试集上的平均效果来总体地评估模型的效果。</p>
<h2 id="正负样本比"><a href="#正负样本比" class="headerlink" title="正负样本比"></a>正负样本比</h2><p>还有一个值得注意的问题，在二分类问题中，当数据集的正负样本比很低时，对模型的训练是很有挑战的，而实际情况往往就是这样的。这种情况下我们通常希望训练集和测试集中的正负样本比可以和总体的比例保持一致，从而降低不平衡数据集带来的影响，因此我们会采用分层的方式来切分测试集。具体而言，假设我们希望切分25%的数据作为测试集，那么我们的做法是分别随机地选取25%的正例和25%的负例作为测试集，剩下的作为训练集。这种分层抽样的方式在实际情况中是非常必要的。</p>
<p>幸运的是，在Scikit-Learn中，<a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html" target="_blank" rel="noopener">StratifiedKFold</a> 可以直接帮助我们完成这一点。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">model_selection</span>.<span class="title">StratifiedKFold</span><span class="params">(n_splits=<span class="number">3</span>, shuffle=False, random_state=None)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n_splits : int, default=3</span><br><span class="line"></span><br><span class="line">Number of folds. Must be at least 2.</span><br><span class="line"></span><br><span class="line">shuffle : boolean, optional</span><br><span class="line"></span><br><span class="line">Whether to shuffle each stratification of the data before splitting into batches.</span><br><span class="line"></span><br><span class="line">random_state : int, RandomState instance or None, optional, default=None</span><br><span class="line"></span><br><span class="line">If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random. Used when shuffle == True.</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>skf = StratifiedKFold(n_splits=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>skf.get_n_splits(X, y)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(skf)  </span><br><span class="line">StratifiedKFold(n_splits=<span class="number">2</span>, random_state=<span class="keyword">None</span>, shuffle=<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> skf.split(X, y):</span><br><span class="line"><span class="meta">... </span>   print(<span class="string">"TRAIN:"</span>, train_index, <span class="string">"TEST:"</span>, test_index)</span><br><span class="line"><span class="meta">... </span>   X_train, X_test = X[train_index], X[test_index]</span><br><span class="line"><span class="meta">... </span>   y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">TRAIN: [<span class="number">1</span> <span class="number">3</span>] TEST: [<span class="number">0</span> <span class="number">2</span>]</span><br><span class="line">TRAIN: [<span class="number">0</span> <span class="number">2</span>] TEST: [<span class="number">1</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://net.pku.edu.cn/~course/cs410/2015/resource/book/2012-book-StatisticalLearning-LH.pdf" target="_blank" rel="noopener">《统计学习方法》 李航</a><br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html" target="_blank" rel="noopener">sklearn.model_selection.StratifiedKFold</a></p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-06-23</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【已解决】tensorflow官网无法访问]]></title>
      <url>/2018/06/18/tensorflow-webpage-changed/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>想看一下tensorflow的官方文档，却无法访问  <a href="https://www.tensorflow.org" target="_blank" rel="noopener">https://www.tensorflow.org</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>官网地址已经改变！</strong>现在的地址是 <a href="https://tensorflow.google.cn" target="_blank" rel="noopener">https://tensorflow.google.cn</a> ，直接访问即可！令人疑惑的是，不知道为什么Google出来的结果包括github上文档给的官方地址还是<a href="https://www.tensorflow.org" target="_blank" rel="noopener">https://www.tensorflow.org</a>，有了解的朋友可以告诉我一声。感谢！</p>
<a id="more"></a>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-06-18</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用pytest进行Python自动化测试]]></title>
      <url>/2018/06/17/pytest-basic-usage/</url>
      <content type="html"><![CDATA[<h2 id="简介与安装"><a href="#简介与安装" class="headerlink" title="简介与安装"></a>简介与安装</h2><p>pytest是一个针对Python的自动化测试框架，它可以使简单的和可扩展的测试变得容易。使用pytest进行测试是简洁和可读的，不需要样板代码，这使得我们可以很方便地进行自动化测试。pytest是一个全平台通用的工具，支持的Python版本包括Python 2.7, 3.4, 3.5, 3.6, Jython, PyPy-2.3</p>
<p>和通常的Python第三方模块一样，pytest可以直接通过pip安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U pytest</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>安装完成后可以运行pytest命令来查看当前版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pytest --version</span><br><span class="line">This is pytest version 3.6.1, imported from /usr/<span class="built_in">local</span>/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/pytest.py</span><br></pre></td></tr></table></figure></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>我们先来创建一个以test_开头的测试函数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># content of test_sample.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_answer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> func(<span class="number">3</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>然后在当前目录下运行pytest命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ pytest</span><br><span class="line">=========================== test session starts ============================</span><br><span class="line">platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y</span><br><span class="line">rootdir: $REGENDOC_TMPDIR, inifile:</span><br><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">test_sample.py F                                                     [100%]</span><br><span class="line"></span><br><span class="line">================================= FAILURES =================================</span><br><span class="line">_______________________________ test_answer ________________________________</span><br><span class="line"></span><br><span class="line">    def test_answer():</span><br><span class="line">&gt;       assert func(3) == 5</span><br><span class="line">E       assert 4 == 5</span><br><span class="line">E        +  where 4 = func(3)</span><br><span class="line"></span><br><span class="line">test_sample.py:5: AssertionError</span><br><span class="line">========================= 1 failed in 0.12 seconds =========================</span><br></pre></td></tr></table></figure></p>
<p>可以看到，pytest自动地运行了test_answer函数，同时提示测试失败，因为func函数的返回值是4，而不是5，所以assert语句报错。</p>
<p>如果想要同时运行多个测试也很简单，在此之前我们需要先了解下pytest是如何确定需要执行哪些测试的。实际上，pytest遵循了标准的<a href="https://docs.pytest.org/en/latest/goodpractices.html#test-discovery" target="_blank" rel="noopener">测试发现守则</a>，具体来说有如下几条：</p>
<ul>
<li>如果没有指定参数，则从<a href="https://docs.pytest.org/en/latest/reference.html#confval-testpaths" target="_blank" rel="noopener">testpaths</a>（如果配置）或当前目录开始。或者可以在命令行参数中使用目录、文件名或节点ID的任何组合。</li>
<li>递归地进入文件夹，除非他们被指定为<a href="https://docs.pytest.org/en/latest/reference.html#confval-norecursedirs" target="_blank" rel="noopener">norecursedirs</a></li>
<li>在这些目录中，寻找形如<code>test_*.py</code>或者<code>*_test.py</code>的文件</li>
<li>在这些文件中，收集如下的这些项目：<ul>
<li>以<code>test_</code>开头的全局函数</li>
<li>以<code>Test</code>开头的类中以<code>test_</code>开头的函数</li>
</ul>
</li>
</ul>
<p>除了上面的规则之外，我们也可以<a href="https://docs.pytest.org/en/latest/example/pythoncollection.html" target="_blank" rel="noopener">配置个性化的测试发现守则</a></p>
<h2 id="在PyCharm中配置pytest"><a href="#在PyCharm中配置pytest" class="headerlink" title="在PyCharm中配置pytest"></a>在PyCharm中配置pytest</h2><p>通常我们会使用IDE进行日常的开发工作，PyCharm是一款针对Python的IDE，深受广大Python爱好者的青睐。我们可以在PyCharm中配置pytest，从而可以直接在PyCharm中使用pytest的功能，方便且高效。</p>
<p>当我们在命令行安装好pytest后，在PyCharm中进入 <em>File | Settings（在Mac OS上是Preferences）| Tools | Python Integrated Tools </em> ，在右边的窗口中有一个 <em>Default test runner</em> 选项，点击下拉框可以看到<code>py.test</code>，选择该项后点击<code>Apply</code>即可。然后我们可以回到写有测试函数的文件中直接<code>右键</code>，会出现一个<code>Run &#39;py.test&#39; for project_name</code>，直接点击即可运行自动化测试。</p>
<p>当然，以上只是pytest基本的用法，还有很多高级的技巧能够进一步简化测试的过程，提高测试的质量，具体的可以到官方文档上查看。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.pytest.org/en/latest/contents.html#toc" target="_blank" rel="noopener">pytest官方文档</a><br><a href="https://blog.csdn.net/liuchunming033/article/details/46501653" target="_blank" rel="noopener">python单元测试框架pytest简介</a></p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-06-17</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【已解决】PyCharm中出现unresolved reference error]]></title>
      <url>/2018/06/16/pycharm-unresolved-reference/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从GitHub上克隆的Python项目，在本地使用PyCharm打开，发现在某个文件的头部导入模块的部分报错<code>Unresolved reference &#39;pytools&#39;</code>，出错的代码如下所示</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytools.model <span class="keyword">import</span> baseline</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们先来看一下整个项目的基本结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pytools</span><br><span class="line">-- note</span><br><span class="line">-- model</span><br><span class="line">   -- baseline.py</span><br><span class="line">-- result</span><br><span class="line">-- src</span><br><span class="line">—- __init__.py</span><br></pre></td></tr></table></figure></p>
<p>pytools是整个项目的根目录，model是它的一个子目录，baseline是model目录下的一个模块。出现这个错误的原因在于PyCharm对于资源的索引方式，pytools作为根目录，无法直接作为模块名访问。因此，我们需要新建一个目录，比如叫做projects，然后将整个pytools项目移到projects目录下，再用PyCharm打开projects目录，程序即可正常运行了。</p>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-06-17</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Scikit-Learn 中文文档完整目录]]></title>
      <url>/2018/06/13/scikit-learn-doc-chinese-catalog/</url>
      <content type="html"><![CDATA[<p><a href="http://scikit-learn.org/stable/index.html" target="_blank" rel="noopener">Scikit-learn</a>是一个开源的机器学习工具包，集成了各种常用的机器学习算法和数据预处理工具。<a href="http://www.apachecn.org/" target="_blank" rel="noopener">Apachecn</a>是一个专注于优秀的开源项目维护的开源组织，在热心网友的共同努力下，对Scikit-learn的文档进行了中文翻译，详情见<a href="http://sklearn.apachecn.org/cn/0.19.0/index.html" target="_blank" rel="noopener">scikit-learn中文文档</a>。本文按照个人的阅读偏好对该文档做了一个目录，便于使用时的检索。全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。</p>
<a id="more"></a>
<h3 id="安装与介绍"><a href="#安装与介绍" class="headerlink" title="安装与介绍"></a>安装与介绍</h3><ul>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/install.html" target="_blank" rel="noopener">安装scikit-learn</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/tutorial/basic/tutorial.html" target="_blank" rel="noopener">使用 scikit-learn 介绍机器学习</a></li>
</ul>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><ul>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html" target="_blank" rel="noopener">广义线性模型</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/lda_qda.html" target="_blank" rel="noopener">线性和二次判别分析</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/kernel_ridge.html" target="_blank" rel="noopener">内核岭回归</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/svm.html" target="_blank" rel="noopener">支持向量机</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/sgd.html" target="_blank" rel="noopener">随机梯度下降</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/neighbors.html" target="_blank" rel="noopener">最近邻</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/gaussian_process.html" target="_blank" rel="noopener">高斯过程</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/cross_decomposition.html" target="_blank" rel="noopener">交叉分解</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html" target="_blank" rel="noopener">朴素贝叶斯</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/tree.html" target="_blank" rel="noopener">决策树</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/ensemble.html" target="_blank" rel="noopener">集成方法</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/multiclass.html" target="_blank" rel="noopener">多类和多标签算法</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/feature_selection.html" target="_blank" rel="noopener">特征选择</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/label_propagation.html" target="_blank" rel="noopener">半监督学习</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/isotonic.html" target="_blank" rel="noopener">等式回归</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/calibration.html" target="_blank" rel="noopener">概率校准</a></li>
<li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/neural_networks_supervised.html" target="_blank" rel="noopener">神经网络模型</a></li>
</ul>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><ul>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/mixture.html" target="_blank" rel="noopener">高斯混合模型</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/manifold.html" target="_blank" rel="noopener">流形学习</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/clustering.html" target="_blank" rel="noopener">聚类</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/biclustering.html" target="_blank" rel="noopener">双聚类</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/decomposition.html" target="_blank" rel="noopener">矩阵分解</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/covariance.html" target="_blank" rel="noopener">协方差估计</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/outlier_detection.html" target="_blank" rel="noopener">新奇和异常值检测</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/density.html" target="_blank" rel="noopener">密度估计</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/neural_networks_unsupervised.html" target="_blank" rel="noopener">受限波尔兹曼机</a></li>
</ul>
<h3 id="模型选择和评估"><a href="#模型选择和评估" class="headerlink" title="模型选择和评估"></a>模型选择和评估</h3><ul>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/cross_validation.html" target="_blank" rel="noopener">交叉验证</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/grid_search.html" target="_blank" rel="noopener">调整超参数</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/model_evaluation.html" target="_blank" rel="noopener">模型评估</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/model_persistence.html" target="_blank" rel="noopener">模型持久化</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/learning_curve.html" target="_blank" rel="noopener">绘制验证曲线</a></li>
</ul>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><ul>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/pipeline.html" target="_blank" rel="noopener">模型合并</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/feature_extraction.html" target="_blank" rel="noopener">特征提取</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/preprocessing.html" target="_blank" rel="noopener">数据预处理</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/unsupervised_reduction.html" target="_blank" rel="noopener">降维</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/random_projection.html" target="_blank" rel="noopener">随机投影</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/kernel_approximation.html" target="_blank" rel="noopener">内核近似</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/metrics.html" target="_blank" rel="noopener">成对的距离度量</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/preprocessing_targets.html" target="_blank" rel="noopener">预测目标预处理</a></li>
</ul>
<h3 id="实用指南"><a href="#实用指南" class="headerlink" title="实用指南"></a>实用指南</h3><ul>
<li><a href="http://sklearn.apachecn.org/cn/stable/datasets/index.html" target="_blank" rel="noopener">数据集加载工具</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/scaling_strategies.html" target="_blank" rel="noopener">大规模计算</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/modules/computational_performance.html" target="_blank" rel="noopener">模型性能</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/tutorial/text_analytics/working_with_text_data.html" target="_blank" rel="noopener">处理文本数据</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/user_guide.html" target="_blank" rel="noopener">用户指南</a></li>
<li><a href="http://sklearn.apachecn.org/cn/stable/tutorial/statistical_inference/index.html" target="_blank" rel="noopener">归纳总结</a></li>
</ul>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-06-13</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> scikit-learn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二分类模型常用评价指标汇总]]></title>
      <url>/2018/06/09/machine-learning-matrix/</url>
      <content type="html"><![CDATA[<p>有很多指标可以衡量机器学习模型的效果，不同的任务使用的评价指标也不尽相同。本文对二分类任务的评价指标加以总结。全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。</p>
<a id="more"></a>
<p>在二分类问题中，数据的标签通常用（0/1）来表示，在模型训练完成后进行测试时，会对测试集的每个样本计算一个介于0~1之间的概率，表征模型认为该样本为阳性的概率，我们可以选定一个<code>阈值</code>，将模型计算出的概率进行二值化，比如选定<code>阈值=0.5</code>，那么当模型输出的值大于等于0.5时，我们就认为模型将该样本预测为阳性，也就是标签为1，反之亦然。选定的阈值不同，模型预测的结果也会相应地改变。二元分类模型的单个样本预测有四种结果：</p>
<ol>
<li>真阳性（TP）：判断为阳性，实际也是阳性。 </li>
<li>伪阳性（FP）：判断为阳性，实际却是阴性。</li>
<li>真阴性（TN）：判断为阴性，实际也是阴性。</li>
<li>伪阴性（FN）：判断为阴性，实际却是阳性。</li>
</ol>
<p>这四种结果可以画成2 × 2的<code>混淆矩阵</code>：</p>
<p><img src="https://raw.githubusercontent.com/coolboygym/images/master/hexo/auc-matrix.png" alt="二阶混淆矩阵"></p>
<p>有了<code>混淆矩阵</code>，就可以定义各种指标了。</p>
<ul>
<li>TPR（真阳性率） = TP / (TP + FN)</li>
<li>FPR（假阳性率） = FP / (FP + TN)</li>
<li>Accuracy（准确率）= (TP + TN) / (TP+TN+FP+FN)</li>
<li>Precision（精确率）= TP / (TP + FP)</li>
<li>Recall（召回率）= TP / (TP + FN)</li>
<li>F1值 = 2TP / (2TP+FP+FN)</li>
<li>PPV（positive predictive value）= TP / (TP + FP)</li>
<li>sensitivity（敏感性）= TP / (TP + FN)</li>
<li>specificity（特异性）= TN / (TN + FP)</li>
</ul>
<hr>
<p>以上就是本文的全部内容，如果您喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-06-12</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用PyCharm进行Python远程开发]]></title>
      <url>/2018/05/20/pycharm-remote-development/</url>
      <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.jetbrains.com/pycharm/2015/03/feature-spotlight-python-remote-development-with-pycharm/" target="_blank" rel="noopener">Feature Spotlight: Python remote development with PyCharm</a>，讲述如何使用<strong>PyCharm</strong>进行<strong>Python</strong>远程开发。全文系作者原创，仅供学习参考使用，转载授权请私信联系，否则将视为侵权行为。码字不易，感谢支持。以下为全文内容：</p>
<a id="more"></a>
<p>这篇博客创作于2015年。如果你正在使用<strong>PyCharm 2018.1</strong>或者更新的版本，请参考<a href="https://blog.jetbrains.com/pycharm/2018/04/running-flask-with-an-ssh-remote-python-interpreter/" target="_blank" rel="noopener">这篇博客</a></p>
<p>各位朋友大家周五好，</p>
<p>在今天的博客中我将介绍<strong>PyCharm</strong>中的一些基本原则和特性，这些特点使得我们可以很容易地进行<strong>Python</strong>远程开发。为了解释和说明这些特性，我将使用一个非常简单的 <a href="https://github.com/pallets/flask" target="_blank" rel="noopener">flask web application</a> 作为例子。尽情享受吧！</p>
<blockquote>
<p>注意：远程开发的特性只针对PyCharm专业版提供。如果想了解更多这方便的信息可以查看 <a href="https://www.jetbrains.com/pycharm/features/editions_comparison_matrix.html" target="_blank" rel="noopener">editions comparison page</a></p>
</blockquote>
<p>首先我从 <a href="https://github.com/pallets/flask" target="_blank" rel="noopener">https://github.com/mitsuhiko/flask</a> 克隆<strong>flask</strong>仓库，然后我在<strong>PyCharm</strong>的欢迎界面打开了<code>blueprintexample</code>目录，这个目录下存储了后面我将用来演示的 <strong>flask application</strong> 的源码。</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask1.png" alt="打开目录"></p>
<p><strong>PyCharm</strong>打开了这个目录并且基于该目录创建了一个项目：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask2.png" alt="创建项目"></p>
<p>现在我准备开始设置远程机器来启动远程开发了。我使用了在<strong>PyCharm</strong>中提供良好支持的<strong>Vagrant</strong>。在我<a href="https://blog.jetbrains.com/pycharm/2013/03/how-pycharm-helps-you-with-remote-development/" target="_blank" rel="noopener">之前的一篇博客</a>中我已经涵盖了<strong>Vagrant</strong>的集成，所以这里提供的仅仅是运行一台<strong>VM</strong>的直接步骤。我在项目的根目录进入 <em>Tools | Vagrant | Init</em> 然后选择了事先从 <a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">collection of vagrant boxes</a> 加载好的<strong>Ubuntu 14.04</strong>的镜像，这个操作会在项目根目录下创建<em>Vagrantfile</em>。现在，我将编辑这个文件来配置一个专用网络，使我的<strong>VM</strong>从我的主机上可见：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask3.png" alt="编辑Vagrantfile"></p>
<p>接着，我将使用 <em>Tools | Vagrant | Up</em> 来启动<strong>VM</strong>，<strong>PyCharm</strong>会向我展示<strong>VM</strong>已经启动并且正在运行：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask4.png" alt="启动VM"></p>
<p>我们可以在<strong>PyCharm</strong>中打开一个本地的终端来测试<strong>VM</strong>：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask5.png" alt="测试VM"></p>
<p>可以看到，<strong>VM</strong>响应了<strong>ping</strong>请求。现在，我想在<strong>VM</strong>上运行我的Web应用程序，所以我需要将我的项目源代码复制到远程主机上。在PyCharm内部部署工具中很容易做到这一点。</p>
<p>我转到 <em>Tools | Deployment | Configuration</em> 并指定了连接<strong>VM</strong>的参数：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask6.png" alt="连接VM"></p>
<p>在同一个窗口下的 <em>Mappings</em> 标签栏中我指定了路径的映射规则：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask7.png" alt="指定路径映射"></p>
<p>在这个例子中我希望我当前的本地目录 <em>blueprintexampe</em> 被映射到远端的 <em>/home/vagrant/blueprintremote</em></p>
<p>现在我可以在项目视图中右键单击我的项目，并选择 <em>Upload to</em> ：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask9.png" alt="上传文件"></p>
<p>这将把我的项目上传到远程机器上的指定目录：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask10.png" alt="上传文件"></p>
<p>最简单的特点之一是，您可以通过单击 <em>Tools | Deployment | Automatic Upload</em> 来设置自动上传：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask11.png" alt="自动上传"></p>
<p>当完成了这个设置后，本地的所有更改将自动上传到远程机器，因此您不必担心远程主机上的代码更新。很酷，不是吗？</p>
<p>所以现在，我要修改我的项目中的一个文件，使得 <strong>flask application</strong> 能够在远端可见（添加 <em>host= ‘0.0.0.0’</em> 作为一个参数到 <em>app.run()</em> ），<strong>PyCharm</strong>会将本地的变化自动上传到远程机器：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask12.png" alt="自动上传"></p>
<p>接下来，我将指定项目所使用的<strong>Python</strong>解释器。我进入 <em>File | Settings（在Mac OS上是Preferences）| Project | Project Interpreter</em>。默认情况下，<strong>PyCharm</strong>将本地<strong>Python</strong>解释器设置为项目解释器，因此我将其更改为远程解释器：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask13.png" alt="设置Python解释器"></p>
<p>由于我已经创建了部署配置，<strong>PyCharm</strong>将开始从现有部署配置导出<strong>Python</strong>解释器设置：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask14.png" alt="导出配置"></p>
<p>但我也可以手动指定远程解释器，使用<strong>SSH</strong>凭据或<strong>Vagrant</strong>配置。在这里我将手动完成：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask15.png" alt="手动配置"></p>
<p>在指定了新的远程<strong>Python</strong>解释器之后，<strong>PyCharm</strong>开始索引，并发现在项目解释器上没有安装<strong>flask</strong>模块：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask16.png" alt="安装新模块"></p>
<p>我可以通过在被红色突出显示的未解决的参考错误上使用 <em>ALT+Enter</em> 轻松解决这个问题：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask17.png" alt="安装新模块"></p>
<p>好吧。现在一切正常，所以我们最终可以指定 <em>Run | Debug</em> 配置并启动我们的应用程序。让我们进入 <em>Run | Edit Configurations</em> 并添加一个新的<strong>Python</strong> <em>Run | Debug</em>配置：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask18.png" alt="配置运行环境"></p>
<p>在 <em>Run | Debug</em> 配置对话框中，我指定新配置的名称和要在远程主机上执行的脚本。<strong>Python</strong>默认设置了这个新的运行配置的项目解释器（在这种情况下为远程），最后我需要为这个特定的运行配置指定路径映射：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask19.png" alt="指定路径映射"></p>
<p>看起来我们都准备好了。我点击运行按钮：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask20.png" alt="运行程序"></p>
<p><strong>PyCharm</strong>显示应用程序在<strong>VM</strong>上的端口5000上运行并运行。我打开浏览器检查应用程序是否真的工作：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask21.png" alt="检查程序运行"></p>
<p>从现在开始，我们可以像通常的本地项目一样使用这个项目。<strong>PyCharm</strong>负责上传任何本地的更改到远程机器并保持<strong>VM</strong>运行。</p>
<p>使用相同的 <em>Run | Debug</em> 配置，我们可以做一个简单的远程调试会话，在编辑器中放置几个断点：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask22.png" alt="调试断点"></p>
<p>单击“调试”按钮或转到“运行调试”：</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/pycharm/files/2015/03/flask23.png" alt="调试程序"></p>
<p>以上就是全部的内容！希望您能理解<strong>PyCharm</strong>的远程开发功能，它能够使得<strong>Python</strong>远程开发成为轻而易举的事。</p>
<p>如果您仍渴望了解<strong>PyCharm</strong>远程开发能力以及其他远程开发功能的详细信息，请参阅<a href="https://www.jetbrains.com/pycharm/help/pycharm.html" target="_blank" rel="noopener">联机帮助</a>。</p>
<hr>
<p>以上就是本文的全部内容，如果你喜欢这篇文章，欢迎将它分享给朋友们。</p>
<p>感谢您的阅读，祝您生活愉快！</p>
<p>作者：<a href="https://coolboygym.github.io" target="_blank" rel="noopener">小美哥</a><br>2018-05-20</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git commit message 编写规范]]></title>
      <url>/2018/05/13/git-commit-message-format/</url>
      <content type="html"><![CDATA[<p>git是软件开发过程中必不可少的代码管理工具，在每次提交新代码时，需要写一些信息表示本次提交所改动的内容。为了方便日后的管理与迭代，commit message最好能有一些固定的格式，让人一眼就能知道每一次提交所做的修改。本文分享一下开源社区常用的代码提交规范，仅供参考。</p>
<a id="more"></a>
<p>完整的commit message格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>有三个大的部分，分别是Header(第一行)、Body和Footer。在Header部分，type字段用于说明commit的类别，允许使用下面7个标识符:</p>
<blockquote>
<ul>
<li>feat: 增加新功能</li>
<li>fix: 修复bug</li>
<li>docs: 编写文档</li>
<li>style: 变换代码风格(不影响代码运行的变动)</li>
<li>refactor: 代码重构(对代码结构有大的改动，但不影响运行)</li>
<li>test: 增加测试代码</li>
<li>chore: 辅助工具的变动</li>
</ul>
</blockquote>
<p>scope字段用于说明本次commit所影响的范围，比如视图层、数据模型或者路由模块等，是一个可选参数。</p>
<p>subject字段是本次commit的一个概要，需要用最简洁的语言来说明本次修改的内容。</p>
<p>在Body部分，可以使用多行文本详细地说明本次提交所改动的一些细节，从而帮助后续的使用者们更好地了解代码的内容。</p>
<p>Footer部分一般只用于两种情况，一是不兼容变动，如果本次的commit与前一个版本的代码无法兼容，那么Footer部分需要以<code>BREAKING CHANGE</code>开头，后面描述本次变动的详细情况以及迁移到新版本代码的方法。</p>
<p>二是关闭Issue，如果本次commit是针对某个Issue，可以在Footer部分以<code>Close</code>开头，后面用<code>#</code>号标识对应的Issue号码。</p>
<p>以上所说的就是完整的commit message的规范写法，在实际开发中，为了提高效率，也可以丢弃Body和Footer部分，在Header的subject字段中写入必要的说明，同时可以加入<code>Fix</code>和<code>Close</code>等标明修复某个bug或者关闭某个Issue，这样既简洁又达到了日常实用的目的。当然团队内部有时候也会针对开发的项目给出对应的要求，总的来说都是为了让开发过程更加的高效和便捷。</p>
<p>参考资料：<br><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a><br><a href="https://www.zhihu.com/question/56120376" target="_blank" rel="noopener">规范的Commit message提交格式</a></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kibana和Elasticsearch允许外网访问]]></title>
      <url>/2018/05/12/kibana-es-access-connection/</url>
      <content type="html"><![CDATA[<p>ElasticSearch(下文简称ES)是一个基于Lucene的搜索服务器，它提供了一个分布式多用户能力的全文搜索引擎。Kibana则是一款开源的分析与可视化平台，可以用来与ES进行交互，通过可视化界面来查看和操作ES中的数据。默认情况下这两个软件只允许通过本机localhost访问。本文分享如何通过设置使得这两者可以被同一网络中的其他机器访问。</p>
<a id="more"></a>
<p>我们先看一下在使用默认设置时，当我们尝试通过IP地址去访问ES的服务(在9200端口)时，会得到如下结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 10.0.0.141:9200</span><br><span class="line">curl: (7) Failed to connect to 10.0.0.141 port 9200: Connection refused</span><br></pre></td></tr></table></figure>
<p>从提示结果可以看到，ES服务拒绝了我们的访问，这是因为ES服务默认监听的主机是localhost，如果希望通过IP进行访问，需要设置其监听<code>0.0.0.0</code>。这个地址表示的是所有未知的主机和目的网络的集合。对于Kibana也是一样的道理，因此以下只阐述ES的配置方法</p>
<p>具体来说，分为两步走，首先要找到ES的配置文件，在不同的系统中配置文件存放的路径也不同。对于Mac系统来说，如果是通过<code>brew</code>安装的ES，那么可以通过以下命令来查看配置文件的位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ brew info elasticsearch</span><br><span class="line">elasticsearch: stable 6.2.3, HEAD</span><br><span class="line">Distributed search &amp; analytics engine</span><br><span class="line">https://www.elastic.co/products/elasticsearch</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/elasticsearch/5.6.3 (217 files, 124MB) *</span><br><span class="line">  Built from <span class="built_in">source</span> on 2017-11-07 at 16:32:00</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/elasticsearch.rb</span><br><span class="line">==&gt; Requirements</span><br><span class="line">Required: java = 1.8 ✔</span><br><span class="line">==&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Data:    /usr/<span class="built_in">local</span>/var/lib/elasticsearch/elasticsearch_gao-yimei/</span><br><span class="line">Logs:    /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/elasticsearch/elasticsearch_gao-yimei.log</span><br><span class="line">Plugins: /usr/<span class="built_in">local</span>/var/elasticsearch/plugins/</span><br><span class="line">Config:  /usr/<span class="built_in">local</span>/etc/elasticsearch/</span><br><span class="line"></span><br><span class="line">To have launchd start elasticsearch now and restart at login:</span><br><span class="line">  brew services start elasticsearch</span><br><span class="line">Or, <span class="keyword">if</span> you don<span class="string">'t want/need a background service you can just run:</span></span><br><span class="line"><span class="string">  elasticsearch</span></span><br></pre></td></tr></table></figure>
<p>结果中的<code>Config</code>标识了配置文件所在的目录。进入该目录，可以看到一个名为<code>elasticsearch.yml</code>的配置文件，通过<code>less</code>命令查看并搜索<code>host</code>可以找到一个<code>network.host</code>的配置参数，我们只需要将该参数前的<code>#</code>号去掉，并将该值设置为<code>0.0.0.0</code>并保存即可。注意第一个<code>0</code>与参数名之间需要有一个空格，这是配置文件的格式要求</p>
<p>修改完成后，还需要一步，那就是重新启动ES服务器，对于Mac用户，可以通过以下命令重启服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew services restart elasticsearch  </span><br><span class="line">Stopping `elasticsearch`... (might take a <span class="keyword">while</span>)</span><br><span class="line">==&gt; Successfully stopped `elasticsearch` (label: homebrew.mxcl.elasticsearch)</span><br><span class="line">==&gt; Successfully started `elasticsearch` (label: homebrew.mxcl.elasticsearch)</span><br></pre></td></tr></table></figure>
<p>等待两三分钟后，服务即可稳定，此时再通过IP访问ES服务，就可以正常使用</p>
<p>值得注意的是，当我们这样设置以后，同一网络中的所有设备都能随意地访问到本机的ES服务，包括所有存储在ES中的数据，这是一个比较危险的操作，因此请谨慎使用。另外，对于其他很多不同的软件，也存在这种默认情况下不允许通过IP访问的问题，设置的方式和ES大同小异，可以参考上述的操作流程。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac设置固定IP地址]]></title>
      <url>/2018/05/12/set-fixed-ip-address-on-mac/</url>
      <content type="html"><![CDATA[<p>在日常的开发过程中，有时候为了方便程序的调试，需要将本机的<strong>IP</strong>地址固定。本文分享下在Mac系统中固定<strong>IP</strong>地址的方法，仅供参考。</p>
<a id="more"></a>
<p>1、点击桌面上的<code>系统偏好设置</code>图标，在打开的设置界面点击<code>网络</code>图标</p>
<p>2、在网络设置界面，点击<code>高级</code>，进入高级设置</p>
<p>3、在高级设置界面，进入<code>TCP/IP</code>选项，点击<code>配置IPv4</code>选项，在下拉框中选择<code>手动</code>，同时设置对应的<code>IPv4地址</code>和<code>路由器</code>地址。注意必须保证此处设置的<code>IPv4地址</code>是内网中还未被使用的，如已被占用会提示错误，需要重新进行填写</p>
<p>4、还是在当前页面，进入<code>DNS</code>选项，在<code>DNS服务器</code>这一栏中添加本地的DNS服务器地址，可能需要问一下网络管理员</p>
<p>5、设置完成，点击右下角<code>好</code>，再继续点击右下角<code>应用</code>，然后重新连接网络，即可使用固定的<strong>IP</strong>地址进行程序开发</p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【已解决】PyCharm证书过期]]></title>
      <url>/2018/04/29/pycharm-license-expired/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天打开<strong>PyCharm</strong>的时候弹出提示框 <code>Your license has expired</code>，表示证书到期了，无法继续使用软件。之前使用的证书是在学校的时候注册的学生账号，也就是以<code>.edu.cn</code>结尾的账号。现在需要寻找一种新的认证方式。</p>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>PyCharm</strong>属于<strong>JetBrains</strong>的一员，这个系列的软件的认证方式有三种，分别是<code>账号登录</code>、<code>激活码</code>和<code>授权服务器</code>。对于在校的学生用户，可以使用<code>.edu</code>后缀的邮箱注册<strong>JetBrains</strong>账号即可免费使用。激活码则需要在官网上购买，也可以在网上找一些共享的激活码，但使用期限和稳定性无法保证，也并非官方推荐的方法。还有一种方法就是通过<code>授权服务器</code>，这种方法相当于把大量可用的<strong>license</strong>聚集起来，然后在多个用户间共享，每个用户每次分配到的<strong>license</strong>可能都不一致。关于<code>授权服务器</code>的更多信息，可以查看<a href="https://www.jetbrains.com/help/license_server/getting_started.html" target="_blank" rel="noopener">官网文档</a></p>
<p>官方提供了一些可用的授权服务器地址，一般是需要付费的。当然也可以自己来搭建<code>授权服务器</code>。这里就分享一下网友<a href="https://www.imsxm.com/buy-me-a-cup-of-coffee.html" target="_blank" rel="noopener">栗小米</a>搭建的<code>授权服务器</code>地址:<code>https://www.imsxm.com</code>，亲测可用，稳定性很高，而且还会保持更新，可以说是非常赞了！</p>
<p>具体的使用方法很简单，打开软件后，在<code>授权页面</code>勾选<code>License server</code>选项，在地址栏输入<code>http://idea.imsxm.com/</code>，再点击右下角的<code>Activate</code>即可。重启软件，弹出提示框<code>Your copy is licensed to imsxm.com</code>，表示软件已经认证成功。也可以在软件内点击菜单栏上的<code>Help</code>选项，单击最后一个选项<code>Register</code>，即可修改认证的方式。</p>
<p>如果各位觉得好用，记得给可爱的<a href="https://www.imsxm.com/buy-me-a-cup-of-coffee.html" target="_blank" rel="noopener">栗小米</a>同学打赏哦，多多支持开源软件！当然，有条件的朋友还是尽可能地购买官方激活码啦，毕竟码农不易，且行且珍惜~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.imsxm.com/jetbrains-license-server.html" target="_blank" rel="noopener">JetBrains 授权服务器</a></p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gensim计算文档相似度]]></title>
      <url>/2018/04/23/gensim-doc-similarity/</url>
      <content type="html"><![CDATA[<p><strong>gensim</strong>是一个基于Python语言的开源工具集，用于处理向量空间模型(vector space modeling)和话题模型(topic modeling)的相关问题。本文分享如何使用<strong>gensim</strong>工具来计算两篇中文文档的相似度。</p>
<a id="more"></a>
<p>首先我们要生成一些中文文档。下面的代码生成一个名为<code>documents</code>的文档列表，由于是演示，这里的每个文档中只有几个词语。关于如何对原始的字符串做分词操作，可以参考<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim <span class="keyword">import</span> corpora</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">documents = [<span class="string">"你好 好的 不错 笨蛋"</span>,</span><br><span class="line">             <span class="string">"笨蛋 傻瓜 傻子 哈哈"</span>,</span><br><span class="line">             <span class="string">"好的 不错 你好 哈哈"</span>,</span><br><span class="line">             <span class="string">"有趣 可以 好的 不错 还行"</span>,</span><br><span class="line">             <span class="string">"傻瓜 傻子 二货 还行"</span>,</span><br><span class="line">             <span class="string">"可以 好的 不错 哈哈"</span>,</span><br><span class="line">             <span class="string">"有趣 有趣 哈哈 哈哈"</span>]</span><br><span class="line">texts = [[word <span class="keyword">for</span> word <span class="keyword">in</span> document.split()] <span class="keyword">for</span> document <span class="keyword">in</span> documents]</span><br><span class="line">pprint(texts)</span><br></pre></td></tr></table></figure>
<pre><code>[[&apos;你好&apos;, &apos;好的&apos;, &apos;不错&apos;, &apos;笨蛋&apos;],
 [&apos;笨蛋&apos;, &apos;傻瓜&apos;, &apos;傻子&apos;, &apos;哈哈&apos;],
 [&apos;好的&apos;, &apos;不错&apos;, &apos;你好&apos;, &apos;哈哈&apos;],
 [&apos;有趣&apos;, &apos;可以&apos;, &apos;好的&apos;, &apos;不错&apos;, &apos;还行&apos;],
 [&apos;傻瓜&apos;, &apos;傻子&apos;, &apos;二货&apos;, &apos;还行&apos;],
 [&apos;可以&apos;, &apos;好的&apos;, &apos;不错&apos;, &apos;哈哈&apos;],
 [&apos;有趣&apos;, &apos;有趣&apos;, &apos;哈哈&apos;, &apos;哈哈&apos;]]
</code></pre><p>然后我们要对原始的文档做一些预处理。这里我们统计了每个词语出现的次数，移除了只出现一次的词语，因为这些词语通常不会对计算文档相似度产生任何贡献。其他的预处理操作还包括移除数字、字母以及标点符号等，这里我们没有展示，如果实际中遇到可以进行相应的处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">frequency = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> text:</span><br><span class="line">        frequency[token] += <span class="number">1</span></span><br><span class="line">texts = [[token <span class="keyword">for</span> token <span class="keyword">in</span> text <span class="keyword">if</span> frequency[token] &gt; <span class="number">1</span>] <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br><span class="line">pprint(texts)</span><br></pre></td></tr></table></figure>
<pre><code>[[&apos;你好&apos;, &apos;好的&apos;, &apos;不错&apos;, &apos;笨蛋&apos;],
 [&apos;笨蛋&apos;, &apos;傻瓜&apos;, &apos;傻子&apos;, &apos;哈哈&apos;],
 [&apos;好的&apos;, &apos;不错&apos;, &apos;你好&apos;, &apos;哈哈&apos;],
 [&apos;有趣&apos;, &apos;可以&apos;, &apos;好的&apos;, &apos;不错&apos;, &apos;还行&apos;],
 [&apos;傻瓜&apos;, &apos;傻子&apos;, &apos;还行&apos;],
 [&apos;可以&apos;, &apos;好的&apos;, &apos;不错&apos;, &apos;哈哈&apos;],
 [&apos;有趣&apos;, &apos;有趣&apos;, &apos;哈哈&apos;, &apos;哈哈&apos;]]
</code></pre><p>接着我们生成了包含所有词语的词典，为后面的计算做准备。在实际情况中，词典通常会很大，为了避免重复计算，可以将词典保存下来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dictionary = corpora.Dictionary(texts)</span><br><span class="line">dictionary.save(<span class="string">'sample.dict'</span>)</span><br><span class="line">print(dictionary)</span><br></pre></td></tr></table></figure>
<pre><code>Dictionary(10 unique tokens: [&apos;不错&apos;, &apos;你好&apos;, &apos;好的&apos;, &apos;笨蛋&apos;, &apos;傻子&apos;]...)
</code></pre><p>有了前一步生成的词典，我们就可以将每个词语转化成一个索引，表示该词语在所有文档中出现的次序，然后每个文档就可以转化成一个索引的列表，比如这里的第一个文档表示为<code>[(0, 1), (1, 1), (2, 1), (3, 1)]</code>，它的含义是在第一篇文档中，第0个词语(也就是“你好”)出现了一次，第一个词语(也就是“好的”)出现了一次，依次类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">corpus = [dictionary.doc2bow(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br><span class="line">corpora.MmCorpus.serialize(<span class="string">'sample.mm'</span>, corpus)</span><br><span class="line">pprint(corpus)</span><br></pre></td></tr></table></figure>
<pre><code>[[(0, 1), (1, 1), (2, 1), (3, 1)],
 [(3, 1), (4, 1), (5, 1), (6, 1)],
 [(0, 1), (1, 1), (2, 1), (6, 1)],
 [(0, 1), (2, 1), (7, 1), (8, 1), (9, 1)],
 [(4, 1), (5, 1), (9, 1)],
 [(0, 1), (2, 1), (6, 1), (7, 1)],
 [(6, 2), (8, 2)]]
</code></pre><p>然后我们可以调用<strong>gensim</strong>中的<code>tf-idf</code>模块来进一步对每个单词计算权重。关于<code>tf-idf</code>的计算方法，可以参考<a href="https://zh.wikipedia.org/wiki/Tf-idf" target="_blank" rel="noopener">维基百科</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim <span class="keyword">import</span> models, similarities</span><br><span class="line">tf_idf = models.TfidfModel(corpus)</span><br><span class="line">vec = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">7</span>, <span class="number">1</span>)]</span><br><span class="line">print(tf_idf[vec])</span><br></pre></td></tr></table></figure>
<pre><code>[(0, 0.3011997233053068), (5, 0.6742695034927825), (7, 0.6742695034927825)]
</code></pre><p>现在，我们可以开始计算两个文档的相似度了。这里我们采用了余弦相似度作为衡量指标，当然还有其他的方式，可以参考<a href="http://manu44.magtech.com.cn/Jwk_infotech_wk3/CN/abstract/abstract4392.shtml" target="_blank" rel="noopener">文本相似度计算方法研究综述</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index = similarities.SparseMatrixSimilarity(tf_idf[corpus], num_features=<span class="number">10</span>)</span><br><span class="line">sims = index[tf_idf[vec]]</span><br><span class="line">print(sims)</span><br></pre></td></tr></table></figure>
<pre><code>[0.08686648 0.37695488 0.10641449 0.43870124 0.38928968 0.63969857
 0.        ]
</code></pre><p>我们还可以将整个相似度矩阵打印出来，就可以看到前面我们所准备的七篇文档两两之间的相似度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(index[tf_idf[corpus]])</span><br></pre></td></tr></table></figure></p>
<pre><code>[[1.         0.3609379  0.71441036 0.13975498 0.         0.20378576
  0.        ]
 [0.3609379  1.0000001  0.08823138 0.         0.64554304 0.08823138
  0.10185669]
 [0.71441036 0.08823138 1.0000001  0.17120475 0.         0.37446705
  0.1440983 ]
 [0.13975498 0.         0.17120475 1.         0.31315398 0.60019135
  0.4952337 ]
 [0.         0.64554304 0.         0.31315398 0.99999994 0.
  0.        ]
 [0.20378576 0.08823138 0.37446705 0.60019135 0.         1.
  0.1440983 ]
 [0.         0.10185669 0.1440983  0.4952337  0.         0.1440983
  0.99999994]]
</code></pre><p>本文中的代码使用<a href="http://jupyter.org/" target="_blank" rel="noopener"><strong>Jupyter Notebook</strong></a>编写，需要的朋友可以直接到<a href="https://github.com/coolboygym/notebook/blob/master/src/gensim-doc-similarity.ipynb" target="_blank" rel="noopener">github</a>上查看。</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gensim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【已解决】Mac安装Jupyter notebook出错的问题]]></title>
      <url>/2018/04/18/jupyter-notebook-install-error/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Mac上安装Jupyter Notebook，按照<a href="https://jupyter.org/install" target="_blank" rel="noopener">Jupyter官网文档</a>进行安装，命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install jupyter</span><br></pre></td></tr></table></figure></p>
<p>安装完成后执行<code>jupyter notebook</code>命令时提示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error executing Jupyter <span class="built_in">command</span> <span class="string">'notebook'</span>: [Errno 2] No such file or directory</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>相关的环境参数</p>
<blockquote>
<ul>
<li>操作系统：macOS 10.13.4</li>
<li>Python版本：Python 3.6.3</li>
</ul>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>依次输入以下两条命令，若提示权限不足在前面加<strong>sudo</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ipython[notebook]</span><br><span class="line">pip3 install jupyter</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Jupyter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs调用SendCloud邮件API2.0]]></title>
      <url>/2018/04/07/nodejs-sendcloud-mail-api/</url>
      <content type="html"><![CDATA[<p>SendCloud作为专业的第三方邮件发送服务提供商，具有高效和稳定的特点，很好地满足平时业务中的相关需求。前一阵在使用时发现原有的邮件API接口升级到2.0了，对于普通发送功能而言，主要的区别在于传递的参数从<code>body参数</code>变成了<code>query参数</code>，由于SendCloud官网还未给出<code>nodejs</code>版本的示例代码，故在此分享，供各位参考。如果需要查看相关文档，请至<a href="https://www.sendcloud.net/doc/email_v2/" target="_blank" rel="noopener">SendCloud官方文档页</a></p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">    apiUser: <span class="string">'your api user'</span>,</span><br><span class="line">    apiKey: <span class="string">'related api key'</span>,</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'service@example.com'</span>,</span><br><span class="line">    fromName: <span class="string">'客服测试'</span>,</span><br><span class="line">    subject: <span class="string">'测试接口功能'</span>,</span><br><span class="line">    to: <span class="string">'somebody@example.com'</span>,</span><br><span class="line">    html: <span class="string">'测试SendCloud邮件API，收到请勿回复，谢谢。'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">require</span>(<span class="string">'querystring'</span>).stringify(param);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    host: <span class="string">"api.sendcloud.net"</span>,</span><br><span class="line">    port: <span class="number">80</span>,</span><br><span class="line">    path: <span class="string">"/apiv2/mail/send"</span>,</span><br><span class="line">    method: <span class="string">"POST"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options.path = options.path + <span class="string">'?'</span> + data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> responseStr = <span class="string">''</span>;</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        responseStr += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(responseStr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>实际使用时，只需要修改参数<code>param</code>的内容填入对应的值即可。有一个值得注意的地方是，新版的邮件发送功能多了一个设置，在<code>首页 -&gt; 邮件 -&gt; 发送设置</code>页面，有一个<code>From开关</code>的设置，它的意思是“如果开启此开关后，自主填写的From的域名后缀不会生效，将和发信域名的后缀保持一致”。所以如果我们需要使用自主填写的<code>From域名</code>，需要先将这个开关设为<code>OFF</code>状态。但这其实并非SendCloud推荐的做法，如果我们需要用自己的域名来发送，最好还是按照SendCloud相应的流程认证之后再使用比较好。</p>
]]></content>
      
        <categories>
            
            <category> coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页短链接的实现原理]]></title>
      <url>/2018/03/31/short-link-implement/</url>
      <content type="html"><![CDATA[<p>网页短链接是指将原本较长的网址转化成较短的网址，从而便于用户的记忆与社交软件上的传播。很多互联网公司都提供了生成短链接的服务，比如<a href="http://dwz.wailian.work/" target="_blank" rel="noopener">新浪微博短网址服务</a>等，本文就来聊聊实现短链接服务的基本原理。</p>
<a id="more"></a>
<p>我们不妨先来看一下短链接服务的整个流程，以前面提到的<strong>微博短网址服务</strong>为例。用户输入想要缩短的长网址，转化后得到一个以<code>http://t.cn</code>开头的短网址，然后用户将该链接通过微信或者微博等方式分享给朋友，其他人点击之后即可进入原本长网址所对应的页面。整个流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/short-link-flow.png" alt="短链接服务整体流程"></p>
<p>从图中可以很清楚地看到，实现短链接服务的关键是两个步骤：1、如何把一个任意长的字符串转化成一个较短的字符串；2、从短网址如何还原出长网址。第一个问题很容易让人想到哈希算法，通过一定的方式将任意长的文本转化成一个固定长度的字符串，只要目标字符串的长度适当，那么不同的输入几乎不可能对应同一个字符串。不过这么做有个缺点就是无法从得到的结果还原输入的字符串，因此不适用于我们的场景。但基于哈希算法的思想，我们可以设计一种<strong>以多进制为基础</strong>的算法完成这个任务。</p>
<p>具体而言，我们可以创建一个用于保存长网址的数据表，比如就叫<strong>Url</strong>，这张表很简单，只需要两个字段，一个<code>主键</code>用于保存<code>id</code>，一个<code>url</code>字段用于存放原始的长网址，每个长网址都在这张表有一条记录。当进行长网址转换时，先检查数据表中是否存在该长网址，若是直接获取该记录的<code>id</code>，否则在数据表中创建一条新记录，并返回其<code>id</code>。对于这个<code>id</code>，我们可以得到一个多进制表示下的新值，比如在以“0-9a-z”这36个字符表示的36进制中，<code>一亿</code>这个数字可以被表示成<code>1njchs</code>，只需要6个字符即可，将这6个字符拼接到准备好的域名后即可得到一个对应的短网址返回给用户。由于一亿个网址只需要6个字符，因此这种方式足够满足大部分网站的需求。</p>
<p>而当用户点击了我们生成的短网址后，只需要将代表多进制的这部分提取出来，还原成十进制的数字后查表即可得到原始的长网址，再根据网址做一个重定向即可让用户访问到原始的网页。具体的实现可以参考下面的<code>typescript</code>代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原始的长链接通过36进制转化为短链接</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">long2short</span>(<span class="params">url: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!url.startsWith(<span class="string">'http://'</span>) &amp;&amp; !url.startsWith(<span class="string">'https://'</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid url'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(config.shortLinkBaseUrl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="keyword">await</span> Url.getByUrl(url);</span><br><span class="line">    <span class="keyword">if</span> (!item) &#123;</span><br><span class="line">        item = <span class="keyword">await</span> Url.create(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config.shortLinkBaseUrl + item.id.toString(<span class="number">36</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将短链接还原为真实的长链接</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">short2long</span>(<span class="params">url: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="keyword">await</span> Url.select(<span class="built_in">Number</span>.parseInt(url, <span class="number">36</span>));</span><br><span class="line">    <span class="keyword">if</span> (!item) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid url'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item.url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>config.shortLinkBaseUrl</code>也就是我们用来做短链接服务的域名，在前面的例子中就是<code>http://t.cn</code>，我们需要在这个域名对应的服务器内实现短链接的服务，同时这个域名本身不能太长，否则就失去了它的意义。另外还有一点值得注意，就是在根据长网址去数据表查找它是否存在时，因为长网址可以任意长，因此直接用它作为索引在数据表中查找的话效率较低，可以考虑在表中增加一个<code>hash</code>字段，保存长网址的哈希值，并通过查找哈希值来判断条目是否存在，提高查找的效率。</p>
<p>以上就是短链接服务的基本实现方法，最核心的其实就是<code>多进制</code>的使用，有兴趣的朋友可以自己动手试试看，有任何问题欢迎留言交流。</p>
]]></content>
      
        <categories>
            
            <category> coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的Bash快捷键]]></title>
      <url>/2018/01/30/bash-shortcut-key/</url>
      <content type="html"><![CDATA[<p>Bash命令行是程序员日常开发中必备的好帮手，掌握一些有效且常用的快捷键可以帮助我们更好地使用bash这个工具，提高工作效率。本文根据笔者个人的经验，总结了一些针对Linux系统的Bash快捷键操作，供各位参考。</p>
<a id="more"></a>
<p>Ctrl + L: 清屏，强迫症患者必备<br>Ctrl + R: 逆向搜索命令的历史记录<br>Ctrl + C: 终止命令，中断一个前台作业<br>Ctrl + A: 光标移动到命令行首<br>Ctrl + E: 光标移动到命令行尾<br>Ctrl + U: 从光标处删除至命令行首<br>Ctrl + K: 从光标处删除至命令行尾<br>Ctrl + W: 从光标处删除至字首<br>Alt + D:  从光标处删除至字尾<br>Ctrl + Shift + C: 在bash中复制<br>Ctrl + Shift + V: 在bash中粘贴<br>方向键上↑: 查看历史中的上一条命令<br>方向键下↓: 查看历史中的下一条命令<br>Command -h: 查看某个命令的帮助文档</p>
<p>虽然数量不多，但都很常用，牢记这几个快捷操作，相信对开发会有帮助的。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PostgreSQL基本用法]]></title>
      <url>/2018/01/11/postgresql-basic-usage/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostgreSQL是一个开源的、对象关系型数据库管理系统（ORDBMS）。本文旨在介绍PostgreSQL（下文简称<strong>pg</strong>）的一些基本操作，供初学者参考和查阅。需要注意的是，以下所有操作是在Ubuntu 16.04中进行的，使用的<strong>pg</strong>版本是<strong>9.6</strong>。对于不同的操作系统和版本，操作流程可能有些许的差别，具体可以参看后面给出的参考文档中的内容。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ubuntu默认集成了<strong>pg</strong>，可以通过命令行直接安装</p>
<p>以下命令分别安装<strong>pg</strong>的客户端和服务端<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install postgresql-client</span><br><span class="line">$ sudo apt-get install postgresql</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，通过以下命令即可启动<strong>pg</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service postgresql start</span><br></pre></td></tr></table></figure></p>
<p>相应的，只要将这里的start改为stop和restart，就可以实现服务的停止和重启</p>
<h2 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h2><p>在初次安装完成后，<strong>pg</strong>默认已经进行了如下的操作：创建了一个名为<strong>postgres</strong>的数据库用户和一个名为<strong>postgres</strong>的数据库，同时还创建了一个名为<strong>postgres</strong>的Linux系统用户。实际上，这里创建的<strong>postgres</strong>数据库用户拥有超级管理员身份，可以访问我们后面所创建的所有数据库，同时可以进行创建新数据库用户和修改用户密码等操作。</p>
<p>为了操作数据库，我们通常需要先登录控制台<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u postgres psql</span><br></pre></td></tr></table></figure></p>
<p>这条命令表示Linux用户<strong>postgres</strong>以超级用户<strong>postgres</strong>的身份登录了名为<strong>postgres</strong>的数据库，因为是Ubuntu系统，所以默认这个时候是不需要输入密码的，直接进入了<strong>pg</strong>的控制台<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>通常我们会在登录后先给postgres用户设置一下密码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \password postgres</span></span><br></pre></td></tr></table></figure></p>
<p>两次输入相同的密码后即可修改成功</p>
<p>因为postgers用户具有很高的权限，通常我们不会直接以这个身份登录，而是会另外创建一个新用户，比如创建一个和当前系统用户同名的数据库用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE USER dbuser WITH PASSWORD 'password';</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们可以为这个新用户创建一个数据库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE exampledb OWNER dbuser;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来我们就可以使用刚才创建的用户登录控制台并连接到创建的数据库中来进行一系列的操作了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ psql -U dbuser -d exampledb</span><br></pre></td></tr></table></figure></p>
<h2 id="常用的控制台命令"><a href="#常用的控制台命令" class="headerlink" title="常用的控制台命令"></a>常用的控制台命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\password           设置密码</span><br><span class="line">\q                  退出</span><br><span class="line">\h                  查看SQL命令的解释，比如\h <span class="keyword">select</span></span><br><span class="line">\?                  查看psql命令列表</span><br><span class="line">\l                  列出所有数据库</span><br><span class="line">\c [database_name]  连接其他数据库</span><br><span class="line">\d                  列出当前数据库的所有表格</span><br><span class="line">\d [table_name]     列出某一张表格的结构</span><br><span class="line">\x                  对数据做展开操作</span><br><span class="line">\du                 列出所有用户</span><br></pre></td></tr></table></figure>
<h2 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 创建新表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>), birth <span class="built_in">DATE</span>);</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(<span class="keyword">name</span>, birth) <span class="keyword">VALUES</span>(<span class="string">'欧文'</span>, <span class="string">'1994-08-23'</span>);</span><br><span class="line"></span><br><span class="line"># 查询记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name;</span><br><span class="line"></span><br><span class="line"># 更新数据</span><br><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'勒夫'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'欧文'</span>;</span><br><span class="line"></span><br><span class="line"># 删除记录</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'欧文'</span> ;</span><br><span class="line"></span><br><span class="line"># 添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> email <span class="built_in">VARCHAR</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"># 更改字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> birth <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"># 设置字段默认值（注意字符串使用单引号）</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> email <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="string">'example@example.com'</span>;</span><br><span class="line"></span><br><span class="line"># 去除字段默认值</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> email <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"># 重命名字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">RENAME</span> <span class="keyword">COLUMN</span> birth <span class="keyword">TO</span> birthday;</span><br><span class="line"></span><br><span class="line"># 删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;</span><br><span class="line"></span><br><span class="line"># 表重命名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">RENAME</span> <span class="keyword">TO</span> backup_table;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> backup_table;</span><br><span class="line"></span><br><span class="line"># 删除库</span><br><span class="line">\c postgres;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hello;</span><br></pre></td></tr></table></figure>
<h2 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pg_dump --format=t -d db_name -U user_name -h 127.0.0.1 -O -W  &gt; dump.sql</span><br><span class="line">$ psql -h 127.0.0.1 -U user_name db_name &lt; dump.sql</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.postgresql.org/docs/9.6/static/index.html" target="_blank" rel="noopener">PostgreSQL官方文档</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="noopener">阮一峰的网路日志</a></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一页纸搞定git命令]]></title>
      <url>/2017/12/04/git-cheat-sheet-cn/</url>
      <content type="html"><![CDATA[<p>本文翻译自<a href="https://www.git-tower.com/blog/posts/git-cheat-sheet" target="_blank" rel="noopener"><strong>Git cheat sheet</strong></a>，通过一页纸的内容搞定<strong>Git</strong>常用命令。</p>
<a id="more"></a>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库：</p>
<p><strong>通过 SSH</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span><br></pre></td></tr></table></figure></p>
<p><strong>通过 HTTP</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> http://domain.com/user/repo.git</span><br></pre></td></tr></table></figure></p>
<p>创建一个新的本地仓库:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>列出当前配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></p>
<p>列出repository配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure></p>
<p>列出全局配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --list</span><br></pre></td></tr></table></figure></p>
<p>列出系统配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system --list</span><br></pre></td></tr></table></figure></p>
<p>设置用户名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name “[firstname lastname]”</span><br></pre></td></tr></table></figure></p>
<p>设置用户邮箱：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email “[valid-email]”</span><br></pre></td></tr></table></figure></p>
<p>设置git命令输出为彩色：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui auto</span><br></pre></td></tr></table></figure></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Repository配置对应的配置文件路径：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.git/config</span><br></pre></td></tr></table></figure></p>
<p>用户全局配置对应的配置文件路径：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure></p>
<p>系统配置对应的配置文件路径：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/gitconfig</span><br></pre></td></tr></table></figure></p>
<h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><p>显示工作路径下已修改的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<p>显示与上次提交版本文件的不同：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure></p>
<p>把当前所有修改添加到下次提交中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure></p>
<p>把对某个文件的修改添加到下次提交中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<p>提交本地的所有修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a</span><br></pre></td></tr></table></figure></p>
<p>提交之前已标记的变化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure></p>
<p>附加消息提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'message here'</span></span><br></pre></td></tr></table></figure></p>
<p>修改上次提交</p>
<blockquote>
<p><em>请勿修改已发布的提交记录!!!</em></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<h3 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h3><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<p>显示所有提交（仅显示提交的hash和message）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure></p>
<p>显示某个用户的所有提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">"username"</span></span><br></pre></td></tr></table></figure></p>
<p>显示某个文件的所有修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<p>谁，在什么时间，修改了文件的什么内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>列出所有分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -av</span><br></pre></td></tr></table></figure></p>
<p>列出所有的远端分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br></pre></td></tr></table></figure></p>
<p>切换分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>基于当前分支创建新分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>基于远程分支创建新的可追溯的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --track &lt;remote/branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>删除本地分支:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>强制删除一个本地分支：</p>
<blockquote>
<p><em>将会丢失未合并的修改!!!</em></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>给当前版本打标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h3><p>列出当前配置的所有远程端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></p>
<p>显示某个远程端的信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>
<p>添加新的远程端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></p>
<p>下载远程端版本，但不合并到HEAD中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>
<p>下载远程端版本，并自动与HEAD版本合并：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>将本地版本发布到远程端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>删除远程端分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -dr &lt;remote/branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>发布标签:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure></p>
<h3 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h3><p>将分支合并到当前HEAD中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>将当前HEAD版本重置到分支中：</p>
<blockquote>
<p><em>请勿重置已发布的提交!!!</em></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>丢弃某次重置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure></p>
<p>解决冲突后继续重置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></p>
<p>使用配置好的merge tool 解决冲突：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<p>在编辑器中手动解决冲突后，标记文件为已解决冲突：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;resolved-file&gt;</span><br><span class="line">$ git rm &lt;resolved-file&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>放弃工作目录下的所有修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure></p>
<p>放弃某个文件的所有本地修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<p>重置一个提交（通过创建一个截然不同的新提交）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --keep &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<p>删除添加.gitignore文件前错误提交的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"remove xyz file"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Elasticsearch更新同义词表]]></title>
      <url>/2017/11/13/update-es-synonym/</url>
      <content type="html"><![CDATA[<p><strong>ElasticSearch</strong>是一个基于<strong>Lucene</strong>的搜索服务器，能够高效地进行查询操作。同义词表是<strong>ES</strong>中的一个辅助工具，可以增加查询操作的灵活性和实用性。在项目开发中，有时会需要更新同义词表，以提供更好的服务。</p>
<a id="more"></a>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>0、Ubuntu 16.04操作系统中，默认情况下，ES的同义词表保存在 /etc/elasticsearch/analysis/synonym.txt 文件中，以下操作以此为例。</p>
<p>1、修改synonym.txt<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/elasticsearch/analysis/synonym.txt</span><br></pre></td></tr></table></figure></p>
<p>根据规则添加所需的同义词条目，具体规则如下图所示，或查看文档<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html</a></p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/update-es-synonym.png" alt="ES更新同义词表"></p>
<p>2、重启ES服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>3、至此，同义词表更新完毕，可以通过观察程序的运行效果来验证是否成功。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac下安装Elasticsearch极简指南]]></title>
      <url>/2017/11/07/install-elasticsearch-osx/</url>
      <content type="html"><![CDATA[<p><strong>Elasticsearch</strong>(以下简称<strong>ES</strong>)是一个面向文档的实时分布式搜索和分析引擎。本文是在<strong>Mac</strong>系统下使用<strong>Homebrew</strong>安装<strong>ES+Kibana+Marvel</strong>的一份极简指南。</p>
<a id="more"></a>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>想要安装<strong>ES</strong>的前提是已经在本机安装了<strong>Java</strong>环境，在命令行键入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure></p>
<p>如果正确打印出版本信息则说明已安装<strong>Java</strong>，否则请到<a href="https://www.java.com/zh_CN/" target="_blank" rel="noopener">Java官网</a>下载最新版安装即可。</p>
<p>另外，本文使用<strong>Homebrew</strong>来安装<strong>ES</strong>，<strong>Homebrew</strong>是<strong>Mac</strong>环境里的一种包管理工具，可以方便地进行软件的安装、更新和卸载操作。如果本机未安装，可以使用以下命令进行安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>完成以上步骤后，本机已具备<strong>Java</strong>和<strong>Homebrew</strong>，进入正题。</p>
<h3 id="安装ES-amp-Kibana"><a href="#安装ES-amp-Kibana" class="headerlink" title="安装ES &amp; Kibana"></a>安装ES &amp; Kibana</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install elasticsearch</span><br><span class="line">$ brew install kibana</span><br></pre></td></tr></table></figure>
<p>以上命令将<strong>ES</strong>和<strong>Kibana</strong>安装到本地，其中<strong>Kibana</strong>是<strong>ES</strong>的一个配套工具，可以让用户在网页中与<strong>ES</strong>进行交互。安装完成后，在命令行键入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew info elasticsearch</span><br><span class="line">$ brew info kibana</span><br></pre></td></tr></table></figure></p>
<p>可以分别看到两个软件的一些安装信息，比如<strong>安装路径</strong>和<strong>配置文件的路径</strong>等，后面会用到。</p>
<h3 id="安装Marvel"><a href="#安装Marvel" class="headerlink" title="安装Marvel"></a>安装Marvel</h3><p><strong>Marvel</strong>也是<strong>ES</strong>的一个插件，能够让你通过<strong>Kibana</strong>非常容易地监视<strong>ES</strong>集群的健康状态等信息。最新版的<strong>Marvel</strong>已经集成到<strong>X-Pack</strong>模块当中。<strong>X-Pack</strong>是<strong>ES</strong>的一个安全框架，可以给网页端访问<strong>Kibana</strong>加入账号系统，使操作更加安全，更多介绍请移步<a href="https://www.elastic.co/products/x-pack" target="_blank" rel="noopener">官方文档</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Cellar/elasticsearch/&lt;whatever version you have&gt;</span><br><span class="line">$ bin/elasticsearch-plugin install x-pack</span><br></pre></td></tr></table></figure></p>
<p>以上命令安装<strong>X-Pack</strong>模块到本地，至此安装部分完成。</p>
<h3 id="启动ES-amp-Kibana"><a href="#启动ES-amp-Kibana" class="headerlink" title="启动ES &amp; Kibana"></a>启动ES &amp; Kibana</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew services start elasticsearch</span><br><span class="line">$ brew services start kibana</span><br></pre></td></tr></table></figure>
<p>启动后可以在本地浏览器访问</p>
<ul>
<li><strong>ES</strong>: <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a></li>
<li><strong>Kibana</strong>: <a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a></li>
</ul>
<p>首次进入<strong>Kibana</strong>页面时需要输入账号名和密码，默认的用户名是<code>elastic</code>，密码是<code>changeme</code>，可以通过以下命令修改密码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XPUT -u elastic <span class="string">'localhost:9200/_xpack/security/user/kibana/_password'</span> -H <span class="string">"Content-Type: application/json"</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "password" : "kibanapassword"</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果不想使用账号密码，可以将<code>下面的配置</code>写入<strong>ES</strong>和<strong>kibana</strong>的配置文件，配置文件所在目录可以通过<code>brew info xxx</code>查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>重启<strong>ES</strong>和<strong>Kibana</strong>后以上配置即可生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew services restart elasticsearch</span><br><span class="line">$ brew services restart kibana</span><br></pre></td></tr></table></figure></p>
<p>然后可以在<strong>Kibana</strong>页面中的<strong>Dev Tools</strong>子页面下直接与<strong>ES</strong>交互。关于<strong>ES</strong>的具体命令，请参看<a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="noopener">《Elasticsearch 权威指南》</a></p>
<p>祝学习愉快==</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> ES </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信公众号开发工具汇总]]></title>
      <url>/2017/11/06/wechat-develop-tools/</url>
      <content type="html"><![CDATA[<p>前面写了篇入坑指南，介绍了下开发微信公众号的基本流程。最近又捣鼓了一阵，发现这开发工具的选择对于提高开发效率真是有莫大的帮助，所谓“只要工具选得好，月底奖金跑不了”。今天得空，笔者就给各位老哥列举几个绝对能派上用场的小工具，保证没毛病！</p>
<a id="more"></a>
<h2 id="微信公众平台技术文档"><a href="#微信公众平台技术文档" class="headerlink" title="微信公众平台技术文档"></a>微信公众平台技术文档</h2><p>这货实际上是必需品，没了它，您还真是寸步难行。官方文档包含了一个产品最直接也最全面的说明，在<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432" target="_blank" rel="noopener">微信公众平台技术文档</a>中，详细说明了微信公众号开发的概念与流程，以及各个接口的调用方法。<strong>开发中遇到的大部分问题都可以在这里找到答案</strong>。值得称赞的是，这份文档还在一开始给出了一份较为详尽的示例程序，通过代码的方式带着读者走了一遍开发的流程，细致全面又不显得啰嗦，可以说是比较用心了，给写文档的妹子点个赞！</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-tool-01.png" alt="微信公众平台技术文档"></p>
<h2 id="微信公众平台接口测试账号"><a href="#微信公众平台接口测试账号" class="headerlink" title="微信公众平台接口测试账号"></a>微信公众平台接口测试账号</h2><p>入坑指南里提到过，当前公众号类型主要分为订阅号和服务号，不同类型账号的主要区别在于接口调用的权限不同，那么如果我们就是想学习下各个接口的调用方法，但手边又找不到一个具有对应权限的公众号该怎么办呢？这时候你可以去申请一个接口测试账号。申请流程很简单，点击网页上的按钮，直接用微信扫码即可。</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-tool-03.png" alt="申请测试账号"></p>
<p>顾名思义，接口测试账号就是专门为开发人员准备的，用于测试接口调用方法的微信公众账号。和普通的公众号一样，可以在网页上对测试账号进行后台的管理，也可以通过扫描二维码的方式来关注测试账号，进行相应的操作。所不同的是，测试账号的名称和<strong>logo</strong>是无法更改的，名称就叫“xxx接口测试号”，<strong>logo</strong>则是个灰色的人头，为的就是把它们和通常的公众号区分开来。很显然，要是能改名改<strong>logo</strong>，那测试号就可以直接用于实际生产环境中了，也就没有必要再去申请公众号。</p>
<h2 id="微信公众平台接口调试工具"><a href="#微信公众平台接口调试工具" class="headerlink" title="微信公众平台接口调试工具"></a>微信公众平台接口调试工具</h2><p>当我们在开发一个新功能的时候，通常希望能先预览一下实际的效果，这样可以对整个任务有一个更加感性的认识。而在开发微信公众号时，接口调试工具就能起到这样的作用。接口调试工具提供了一组图形化界面，通过简单地输入一些参数，就可以实现各个接口的调用，并立即在公众号上查看对应的效果。<strong>这种交互方式非常直观，也非常高效</strong>。此外接口调试工具还可以帮助我们进行<strong>debug</strong>，当我们在开发中遇到一直无法调通某个接口的情况时，可以将使用到的参数直接复制到接口调试工具的网页上，从而观察运行结果是否符合预期，通过比较两种方式调用结果的异同，我们可以更准确地找到<strong>bug</strong>所在。当然，关于<strong>debug</strong>这一点，下文介绍的工具才是真正的利器。</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-tool-04.png" alt="接口调试工具"></p>
<h2 id="微信web开发者工具"><a href="#微信web开发者工具" class="headerlink" title="微信web开发者工具"></a>微信web开发者工具</h2><p>入坑指南里提到过，微信网页开发已经成为整个微信公众号开发当中很重要的一分部。事实上，在微信公众号开发中，设置自动回复规则和下拉菜单这两项所能提供给用户的服务非常有限，要想完成一些比较复杂的逻辑交互，就必须实现微信公众号内的网页开发。</p>
<blockquote>
<p><strong>网页开发就是指编写一系列的HTML5页面，并在微信公众号中引导用户打开我们开发的页面，从而实现相关的业务逻辑，这一功能使得公众号可以像一个内嵌在微信当中的应用一样，能够实现非常复杂的交互逻辑，而且相比于通常的应用来说更加小巧。</strong></p>
</blockquote>
<p>做过前端开发的老哥们对于浏览器中的“<strong>检查元素</strong>”这个功能一定都不陌生。当下前后端的开发通常是分离的，二者通过API接口进行对接。前端开发过程中为了进行调试，通常会在网页中打开“<strong>检查元素</strong>”功能来查看后端的回复是否正确，从而发现代码中可能存在的bug。而当我们进行微信web开发时，公众号里的网页是由微信自带的浏览器进行解析的，我们只能看到网页的效果，却无法看到任何有关前后端通信的数据，这样一来，当错误出现时，我们也就无从知道究竟是前端的锅还是后台的锅，这自然会影响开发的效率。微信团队的大佬们自然也想到了这一点，于是便有了web开发者工具这一调试利器。</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-tool-02.png" alt="微信web开发者工具"></p>
<p>微信web开发者工具实际上就是个<strong>自带“审查元素”功能的微信浏览器</strong>。通过扫码的方式，我们可以用自己的微信账号来登录这个软件。在登录之后，它就成为了一个可以在电脑桌面上打开的“微信浏览器”，<strong>通过在地址栏输入前端网页的地址，我们可以模拟在手机上的微信公众号中点击了某个网页的行为</strong>，当然此时前后端通信的数据也就一目了然。我们可以按照网页上的逻辑进行操作，就好像我们在一个普通的浏览器中所做的一样，简单好用，可以说是非常走心了。</p>
<hr>
<p>以上就是笔者在捣鼓微信公众号时经常用到的一些小工具，回想起来，它们确实给开发过程带来了很大的帮助，在此分享给各位老哥，希望对各位有所帮助。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wechat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[优秀的程序员是什么样的？]]></title>
      <url>/2017/11/03/do-not-trust-user-input/</url>
      <content type="html"><![CDATA[<p>在程序员的世界里有一句经典的至理名言：永远不要相信用户的输入。相信很多开发者都有过类似的踩坑经历，所谓“幸福的人都是相似的，而编程的人是幸福的”。</p>
<a id="more"></a>
<p>初入职时，作为一名后端工程师，每次实现接口后，老大(我的组长)都会过来帮我瞄一眼，然后提出一堆改进意见，其中最常被提到的一点就是：永远不要相信用户的输入。我不以为意，没怎么去改相关逻辑，这么做的后果就是老大下次再帮我检查时，总会伴随一阵悦耳的争辩声。</p>
<blockquote>
<p><strong>Round 1</strong></p>
</blockquote>
<p>你这里为什么不加个类型检查？万一接收到的值不是数组怎么办？</p>
<p>怎么会呢，这些接口类型都是和前端定好的呀。</p>
<p>前端传入的数据是可以被篡改的，万一有人模拟了一个前端请求，发送一个其他类型的变量，那你的程序不就炸了？</p>
<p>那样的话程序会返回服务器异常，攻击者也不会得到什么有用的信息吧…</p>
<p>是没什么损失，但为什么要给别人留下这么个漏洞呢？</p>
<p>哦哦…</p>
<blockquote>
<p><strong>Round 2</strong></p>
</blockquote>
<p>这个接口传入的是图片对吧，为什么不检查下图片的大小？</p>
<p>这个，前端已经检查过了，太大的图片前端会先进行压缩的。</p>
<p>不是和你说过了吗，永远不要相信前端的输入！万一有攻击者模拟前端接口发来很大的图片呢？</p>
<p>额，不是还有<code>nginx</code>可以挡一道吗？太大的图片应该直接无法响应吧。</p>
<p><code>nginx</code>的确能做这个，但这些也是需要配置参数的，万一不小心参数设太大了没发现怎么办？</p>
<p>哦，那就只能接收并保存下来了，不过我们的图片不都放在<code>s3</code>上吗，大一点也没什么关系吧，存储也挺便宜的…</p>
<p>你太天真了！首先，<code>s3</code>也是要花钱的，虽然空间不贵，但流量贵啊，万一真被人发现这个漏洞，他们完全可以把大量的图片通过你这里上传，然后根据返回值里的图片链接去获取。甚至如果有不怀好意的人传了些不该传的东西上去，那咱说不定都要去局里坐坐，这可不是开玩笑。</p>
<blockquote>
<p><strong>Game Over</strong></p>
</blockquote>
<p>这下我算彻底服了，只好满口答应，然后老老实实把该补的补上。嘴上虽这么说，但心里难免还有点疙瘩，这些都是特殊情况嘛，哪有那么容易就发生。事情总是这样，只要还没在自己身上发生，就会抱有侥幸心理，认为它一定不会发生，等到真的发生了，又来责怪自己当初怎么那么不小心。笔者就有过这么个经历，虽没犯下什么大错，但也足够长点记性了。</p>
<hr>
<p>话说最近在做微信公众号开发，某天<strong>PM</strong>(产品经理)姐姐拿着个新需求过来，说是要加一个批量导入历史用户的功能，我扫了一眼开发文档，在<code>用户管理</code>文档中找到了<code>获取用户基本信息</code>这一项，心想不正是这个接口么，于是自信地回了句：“明天下班前给你”，转头就热火朝天地敲起了键盘。</p>
<p>整个流程比较清晰，先通过接口调用凭据<code>access_token</code>获取用户的<code>openid</code>列表，再调用<code>获取用户基本信息</code>接口来得到用户的昵称等信息，再将获取到的信息存到数据库即可。不过，作为一个严谨的开发，当然不能这么草率，还要考虑下效率和安全的问题。微信公众号里的用户动不动就上万，要一个个去获取基本信息那绝对是不妥当的，这一点微信团队的大佬们当然也想到了，所以提供了一个批量获取微信用户信息的接口，甚是方便。</p>
<p>另外，将数据存储到数据库时，当然也不能一条条地存入，这样一不小心得把数据库整挂了。应该在程序里构造<code>sql</code>语句，累计到一定的用户量之后再以批量的方式插入，这样不仅减少了操作数据库的次数，而且直接执行<code>sql</code>语句的方式也更加高效。</p>
<p>考虑完这两点后，就开始敲代码了。手指翻飞间，几个接口函数已经基本完成，打开编译器，一路绿灯，又麻利地打开本地的前端服务，准备开始调试。点击<code>导入历史用户</code>按钮，后端收到请求，调试器里查看，微信正确地返回了<code>用户列表</code>，因为线下的环境只是个测试号，所以只有20人左右，继续点击下一步，用户信息也成功获取，下一步，<code>sql</code>语句执行成功，全部用户导入完毕，到数据库里一看，数据确实都存下来了，搞定！</p>
<p>接下来，就是将程序上线了。虽然只是个小功能，可一旦要上线都是需要找老大来的，毕竟万一线上的代码真出了问题这锅最后还得到他头上。于是我就跑去找来了他，他当然也知道我今天在开发这个功能，看我不到半天就完成了，还捎带夸了句：完成地挺快呵。我自然是轻扬起嘴角，淡淡地回了句：这活还蛮简单的。</p>
<p>然而，这种笑容很快就消失了，因为我看到坐在我电脑前的老大眉头紧缩，顿觉头顶乌云密布。果然，不到一会儿，就传来了老大的“盘问”。</p>
<p>你直接用<code>sql</code>语句来插入数据的？</p>
<p>嗯，感觉这样子更方便一点，效率也更快点。</p>
<p>这个想法是没错，但你这里有个问题啊，在构造<code>sql</code>语句的时候，要特别注意单引号的使用，你看你这里在每个变量的两边显式地加入了单引号，那要是变量的字符串里本身就包含单引号怎么办呢？</p>
<p>啊，变量的值怎么可能会有单引号啊，这一点我没想到诶。</p>
<p>怎么不可能？你这里的值是微信用户的信息对吧，万一哪个家伙无聊在昵称里加了个单引号呢，这完全是可能的，这种时候你的<code>sql</code>语句就会被这个单引号提前封闭，就会产生语法错误，也就无法正常地执行了。更要命的是，这个时候用户单引号后面的部分就成为了<code>sql</code>命令的一部分被执行了，万一来个<code>drop database</code>之类的，再加个单引号把原来的部分还原，那这就成了典型的<code>注入攻击</code>了。到时候你哭都来不及。</p>
<p>哇靠，原来还有这种操作啊，我如梦初醒，不觉后背发凉。之前听老大提起过在<code>php</code>时代著名的注入攻击的案例，没想到今天自己竟差点犯了这个错误，真是罪过。那该怎么解决呢？我向老大请教。</p>
<p>这个其实也挺简单，只要把可能存在的特殊字符给转义就行了，这样它们就不会变成<code>sql</code>的一部分被执行。</p>
<p>嗯，有道理。于是我就噼里啪啦改起来，不一会儿就把该转义的给转义了，老大看完微微点头，然后再次强调说，特别是涉及到数据库的操作时，一定要严格地检查用户的输入，考虑所有可能的情况，防止出现这样的问题。我毕恭毕敬地听着，点头如捣蒜。</p>
<p>不过事情还没完。老大紧接着又指出另一个问题：你在接收到微信服务器返回的用户信息列表时，有检查它的类型吗？</p>
<p>我有点疑惑，这个类型不是在微信的文档里写好的嘛，只能是<code>JSON</code>啊，难道这也需要检查吗？</p>
<p>老大貌似看出了我的疑虑，问到：万一用户的信息里确实有一些特殊的字符，没办法用<code>JSON</code>的方式传输呢？是不是需要先将<code>JSON</code>做个序列化再传输呢？而你没有判断返回值的类型，完全按照<code>JSON</code>的格式来处理，这样后面有可能会出错的。</p>
<p>我还是有点疑惑，不就是个昵称嘛，能有什么特别的字符呢？</p>
<p>老大看了看我，建议我现在去试下微信修改昵称的功能。这不看还真不知道，在改昵称的时候原来可以插入表情的啊，还不止是微信官方提供的表情，而是能添加自己私藏的任意表情，表情是海量的，而<code>JSON</code>能识别的字符集是有限的，这么一来也就自然会出现一些<code>JSON</code>无法识别的字符。</p>
<p>看到这，我算是相信了，于是又把类型检查给加上了，并且当接收到的类型是字符串时，对其进行了处理，消除了里面可能存在的非<code>JSON</code>字符。老大看了看我，这次算是露出了比较满意的表情。</p>
<p>最后，又检查了一遍，为了验证刚才老大的两个想法，我还特意加了一个记录日志的操作，看看接收到的信息到底都是些啥。确认无误后，老大把程序更新到了线上。两三分钟后，更新完成，我迫不及待地尝试了下这个新功能。说来您还真别不信，线上用户的公众号总共有两万多关注者，这些人里面居然真的有人在昵称里使用了单引号，而且这类人还不少，大概三四百人里就有一个。而且返回的用户信息列表居然真的不全是<code>JSON</code>格式的，而是有部分<code>string</code>格式的，将这些<code>string</code>解析后得到的<code>JSON</code>里面，确实包含了一些无法识别的字符。</p>
<p>我看着日志里的结果，又看了看微信公众平台的官方文档，再回头看看老大那挂着浅浅笑容的脸颊，不禁肃然起敬。一方面是觉得尽管诸如微信这样的官方文档也难免会有疏漏之处，不可一味地根据主观意向来判断。再者，则是对老大的远见卓识佩服之至。我记得曾在知乎上看到过一个问题，大意是说</p>
<blockquote>
<p><strong>做一个优秀的程序员到底难在哪里？</strong></p>
</blockquote>
<p>答案里有一条是这么写的：</p>
<blockquote>
<p><strong>由于你是一个优秀的（或仅仅是经验丰富的）程序员，你可以看出项目代码里存在着的隐患。你选择防患于未然，修复这些问题，但由于问题并没有真的发生，你所做的一切，在不那么优秀的程序员同事的眼中（以及老大眼中），看起来并没有什么产出。</strong></p>
</blockquote>
<p>诚哉斯言。回想起先前的经历，要不是老大及时指出代码里可能存在的错误，那肯定是要出问题的，虽然这一次不一定导致什么严重的后果，但若问题不除，迟早要吃大亏。此时老大已经起身准备离开了，他还有一大堆的事情要忙呢。不过在临走前，他又一次嘱咐了我：永远不要相信用户的输入。</p>
<p>嗯，这次我是真的记住了。望着老大远去的背影，我在心里默念到。</p>
<p>大概，这就是我心目中优秀程序员该有的样子。</p>
<hr>
<p>参考链接</p>
<p><a href="https://www.zhihu.com/question/63152623/answer/206189038" target="_blank" rel="noopener">做一个优秀的程序员到底难在哪里？ - Van Bruce的回答 - 知乎</a></p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你入门微信公众号开发]]></title>
      <url>/2017/11/01/basic-wechat-develop/</url>
      <content type="html"><![CDATA[<p>这是一篇关于微信公众号开发的入门指南，较为详细地介绍了开发微信公众号的基本原理，并且有相应的代码实现。如果您正打算要做公众号开发，却又苦于找不到一份简洁明了的入门级教学文档，那么这篇博客应该能解决您的问题。</p>
<a id="more"></a>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><blockquote>
<p><strong>近日腾讯发布2017年中报，报告中指出，腾讯二季度实现营业收入566.06亿元，经营盈利、期内盈利分别达到225.6亿元和182.54亿元。按照当前利润与员工数估算，腾讯员工的平均年薪达到80万…</strong></p>
</blockquote>
<p>尽管很多人吐槽王者荣耀里的小学生太坑爹，但不得不承认，近年来腾讯的变现能力确实强大地吓人。这之中微信和QQ作为用户的入口，起到了很大的作用。特别是微信，已然是一款装机必备的全民软件，如何借助这个庞大的平台搞点事情，分享下微信带来的用户红利，也就成为一件很值得研究的事。微信公众号是个人或者企业的一个宣传平台，通过开发微信公众号，可以给关注公众号的用户提供更多定制化的服务，进一步可以将服务转化为效益。本文旨在给正准备做微信公众号开发的朋友分享一点经验，从而尽快熟悉微信公众号开发的整体流程。在此基础上可以继续去学习一些高级的开发技巧（<em>比如微信支付、账单系统之类的</em>），让自己的公众号更加地精(<em>zhi</em>)美(<em>qian</em>)。</p>
<h2 id="磨刀不误砍柴工"><a href="#磨刀不误砍柴工" class="headerlink" title="磨刀不误砍柴工"></a>磨刀不误砍柴工</h2><p>微信公众号大家肯定都用过。目前微信公众号主要分为订阅号和服务号，每种账号又分为未认证和已认证，<strong>它们的差别主要在于具有不同的接口权限</strong>，下图（<em>引用自<a href="http://www.cnblogs.com/liuhongfeng/category/737139.html" target="_blank" rel="noopener">微信开发实战系列</a></em>）是一些例子：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-7.png" alt="不同类型公众号的权限"></p>
<p>总体来说，服务号权限 &gt; 订阅号权限，认证账号权限 &gt; 未认证账号权限。申请订阅号比较简单，服务号相对复杂点，另外要认证的话还要额外提交一些材料。我们可以根据不同的业务需求去申请不同类型的账号，基本上常用的权限列表已经可以满足大部分的场景。</p>
<p><strong>开发微信公众号本质上和通常的网站开发并无区别</strong>。当我们进入一个公众号页面之后，我们可以向公众号发送文字、语音、图片等消息，也可以通过点击页面下方的菜单触发相应的功能。<strong>那么开发者与微信用户究竟是怎么进行交互的呢？</strong>实际上我们在公众号里的所有操作，都会发送到微信的服务器上，微信服务器将这些动作的具体含义按照一定的格式进行封装后，发送到微信公众号所对应的服务器上（<em>这个服务器的地址可以由开发者在微信公众号的后台进行配置</em>），开发者通过编写代码来处理不同的用户行为，并将处理后的结果按照一定的格式返回给微信服务器，再由微信服务器发送到微信公众号里面，从而完成了一次交互过程。在这里借用<a href="http://www.cnblogs.com/txw1958/p/wechat-tutorial.html" target="_blank" rel="noopener">方倍老师博客</a>中的一张图片来展示下这个过程，可以帮助大家理解地更清楚：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-5.png" alt="微信用户与开发者的交互流程"></p>
<p>到这里我们可以知道，所谓的微信公众号开发，其实就是编写业务代码来处理用户的动作请求。这里面会涉及到和微信服务器之间的通信，也就涉及到一些安全认证方面的知识，后文会通过一个实际的例子进行说明。现在，就让我们来看看具体的流程吧。</p>
<h2 id="巧妇难为无米之炊"><a href="#巧妇难为无米之炊" class="headerlink" title="巧妇难为无米之炊"></a>巧妇难为无米之炊</h2><p>开发微信公众号需要准备以下两样食材：</p>
<h3 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h3><p>微信公众号可以在<a href="https://mp.weixin.qq.com" target="_blank" rel="noopener">微信公众平台的官网</a>上申请。前文说过，微信公众号分为几种类型，不同的类型具有不同的权限，具体的权限列表可以查看<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084" target="_blank" rel="noopener">微信公众平台技术文档</a>。值得注意的是，现在已经不再支持个人类型的公众账号申请微信认证。申请的过程无非是填写下邮箱和信息，建议使用QQ邮箱，毕竟是自家的东西。</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>由于我们的服务器需要与微信服务器进行交互，因此必须能够让微信服务器可以访问到。很多公司都提供了云服务器租赁，价格不一，可以自行申请，细节在此不表。如果不想花钱申请，也可以使用一些外网穿透工具，将本地的IP暴露到公网中供外部访问，具体的工具请自行百度，不过大部分软件稳定性无法保证，而且分配的域名经常改变。个人建议还是申请一台服务器比较方便，等以后公众号运营良好开始涨(<em>ying</em>)粉(<em>li</em>)了，这些都不是事~</p>
<h2 id="撸起袖子加油干"><a href="#撸起袖子加油干" class="headerlink" title="撸起袖子加油干"></a>撸起袖子加油干</h2><p>以下是详细步骤：</p>
<h3 id="开启公众号开发者模式"><a href="#开启公众号开发者模式" class="headerlink" title="开启公众号开发者模式"></a>开启公众号开发者模式</h3><p>为了让微信服务器知道开发者服务器的存在，必须在公众号后台进行相应的配置。<br>(1) 登录<a href="https://mp.weixin.qq.com" target="_blank" rel="noopener">公众平台官网</a>，找到左边功能栏的最下方，有一个<strong>基本配置</strong>的选项</p>
<p>(2) 点击<strong>基本配置</strong>按钮，在右边的页面中填写服务器的相关信息。其中<strong>URL填写<a href="http://外网IP:端口号/wx" target="_blank" rel="noopener">http://外网IP:端口号/wx</a></strong>，这里外网IP是服务器的外网IP地址，端口号固定填写80。Token可以自由填写，用于两个服务器之间的验证。具体见下图： </p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-0.png" alt="配置微信公众号"></p>
<p>(3) 点击提交按钮，提示<strong>配置失败</strong>。这是自然的，因为我们还需要在开发者服务器上进行配置，才能完成验证的过程。</p>
<p>(4) 前面在配置微信公众号时为什么提示失败呢？在此我们有必要探究下这个认证过程。当我们点击了提交后，微信服务器会向我们所填写的那个URL发起一个GET请求，并携带以下几个参数：timestamp, nonce, echostr, signature。其中timestamp是一个时间戳，nonce是一个随机数，echostr也是随机数，这几个都很普通，重点在于signature，它的生成方式是将nonce、timestamp和token（<em>也就是我们在网页中配置的TOKNE</em>）三个字符串按照字典序排序后，对排序后得到的字符串数组使用哈希加密算法得到。我们的服务器在收到这个GET请求后，提取对应的参数，并按照前面说的方式生成hashcode，如果这个值与参数中的signature相同，那么我们就将echostr返回给微信服务器，否则返回空值。微信服务器收到这个echostr之后，验证这个值与它发送的echostr值是否相同，如果相同，说明这个值的确是由我们的服务器返回的，从而完成验证，今后所有的信息就都可以发送到这个服务器地址上。这里面涉及到了一些安全认证的相关知识，有兴趣的朋友可以去查阅更详细的资料。<strong>总的来说，就是让通信的双方都能够确认对方的真实身份</strong>。以下是认证部分的主要代码，使用<a href="https://docs.python.org/2.7/" target="_blank" rel="noopener">Python2.7</a>和<a href="http://webpy.org" target="_blank" rel="noopener">web.py</a>框架编写：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-1.png" alt="验证开发者服务器"></p>
<h3 id="编写服务器业务逻辑"><a href="#编写服务器业务逻辑" class="headerlink" title="编写服务器业务逻辑"></a>编写服务器业务逻辑</h3><p>前面我们完成了微信服务器与开发者服务器的相互认证过程，接下来我们需要编写业务逻辑代码来处理微信服务器发送过来的信息。以文本消息为例，当用户在公众号页面发送了消息后，微信服务器会将这条消息封装成如下的<strong>XML</strong>格式，并将其作为请求的内容向开发者服务器发起一个<strong>POST</strong>请求：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-4.png" alt="微信服务器封装的请求内容"></p>
<p>各个字段的具体含义就如字段名所示，比较直观。我们首先需要解析这个XML对象，并提取出各个字段用于后续的处理：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-3.png" alt="解析XML对象"></p>
<p>解析之后，我们可以在<strong>主函数</strong>中根据消息的不同类型，来调用不同的处理函数得到相应的处理结果，然后我们要将处理结果封装成同样的<strong>XML</strong>格式返回给微信服务器，封装XML对象的代码如下所示（以文本消息为例）：</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/wechat-2.png" alt="封装XML对象"></p>
<p>至此，我们就完成了一个简单的回复流程（虽然目前这种只能回复文本消息==）。</p>
<h2 id="更上一层楼"><a href="#更上一层楼" class="headerlink" title="更上一层楼"></a>更上一层楼</h2><p>以上就是一个基本的微信公众号开发流程。当然，想要让我们的公众号变得多姿多彩，需要掌握的内容还有很多。比如</p>
<p>(1) <strong>access_token</strong>：前面我们所做的实际是被动回复消息，微信服务器发起POST请求，我们将处理后的内容借由微信服务器返回给用户。如果我们需要主动地和用户进行交互，比如主动地向用户发一条消息，我们就需要调用微信公众平台提供的相应接口，并且需要主动告诉微信服务器我们的身份，这是通过<strong>access_token</strong>实现的。</p>
<blockquote>
<p><strong>access_token</strong>是微信公众号的全局唯一接口调用凭据，公众号在调用各个接口时都需要使用<strong>access_token</strong>。</p>
</blockquote>
<p>如上所述，在我们调用各个接口前，需要先使用公众号的<strong>appid</strong>和<strong>appsecret</strong>信息（这两个值可以从微信公众号的网页上查看）向微信服务器请求获取<strong>access_token</strong>，然后带着这个值去调用微信公众平台提供的接口，实现相应的功能。</p>
<p>(2) <strong>微信网页开发</strong>：网页开发就是指编写一系列的<strong>HTML5</strong>页面，并在微信公众号中引导用户打开我们开发的页面，从而实现相关的业务逻辑，这一功能使得公众号可以像一个内嵌在微信当中的应用一样，能够实现非常复杂的交互逻辑，而且相比于通常的应用来说更加小巧。</p>
<h2 id="从这里出发"><a href="#从这里出发" class="headerlink" title="从这里出发"></a>从这里出发</h2><p>以上就是本文的主体内容。楼主经验尚浅，斗胆提笔撰文，有不当之处欢迎各位指出。本文主要是一个入门的简介，后续的开发还有很多内容要学，以下列出一些个人认为比较不错的文档和资料，楼主也从中学到了很多，在此感谢各位作者。</p>
<p>(1) <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432" target="_blank" rel="noopener">微信公众平台技术文档</a><br>(2) <a href="http://www.cnblogs.com/txw1958/p/wechat-tutorial.html" target="_blank" rel="noopener">方培工作室-微信公众平台开发教程</a><br>(3) <a href="https://github.com/Wechat-Group" target="_blank" rel="noopener">微信开发者联盟</a><br>(4) <a href="http://www.cnblogs.com/liuhongfeng/category/737139.html" target="_blank" rel="noopener">微信开发实战系列</a></p>
<p>本文中的代码已上传到<strong>github</strong>，里面包含了微信公众号一些常用功能的实现，仅供参考：<a href="https://github.com/coolBoyGym/wechatdemo" target="_blank" rel="noopener">微信公众号开发示例程序</a></p>
]]></content>
      
        <categories>
            
            <category> coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wechat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我们都曾行走在白夜里]]></title>
      <url>/2017/11/01/bai-ye-xing-note/</url>
      <content type="html"><![CDATA[<p>当我合上书本，再次看到封面上牵着手的小男孩和小女孩时，一种莫名的难过翻涌而来，投射到墙上的阴影仿佛要将整个房间笼罩。那里本该洒满阳光。</p>
<p>东野大叔的叙事风格宛若天马行空，这一点在《解忧杂货店》中就充分感受过，相比起来，《白夜行》可谓有过之而无不及，乃至于第一遍捧起书时到第五章就看不下去了，我已经忘了前面都说了啥。我是怀着一点猎奇的心来的，顶尖的推理小说作家，悬疑的杀人案件，如潮水般的好评，这足以让人坚信这本书能给人带来精彩的阅读体验。</p>
<a id="more"></a>
<p>但很显然，那时的我并没感受到。紧张的案件叙述部分在第一章的末尾戛然而止，接下来时光不断往前推进，各色人物一个接一个出现，发生的故事似乎没什么联系，那桩案子也宛如投向湖中的石子，随着波纹的远去逐渐淡出人们的视野。</p>
<p>难道就这样了吗？我不禁暗自揣测。合上书本，我瞅了眼封面，两个小孩子携手同行，他们的影子被拉得老长。这幅画有什么含义呢？我实在搞不懂。但东野大叔应该不会让人失望吧。</p>
<p>于是我又把书翻到了第一页。</p>
<p>东野大叔也确实没让人失望。</p>
<p>天网恢恢，疏而不漏。尽职的老刑警追了十九年，终于亲手将真凶绳之于法，而另一位主谋唐泽雪穗，则在失去唯一的精神支柱后彻底卸下了伪装。</p>
<blockquote>
<p><strong>她一次都没有回头。</strong></p>
</blockquote>
<p>这是全文的结尾，也是最精彩的地方之一。初看起来，这句话似乎进一步表现了雪穗的心狠手辣，对于和自己相依为命的伙伴的死也毫不在乎，但考虑到当时的场景，一个“陌生人”在自己店门口死亡，换做普通人应该会和她的店员们一样惊慌失措，而她却没有丝毫的情绪变化，这恰恰说明她此刻内心的波动之大，甚至让她忘记了身上一直披着的那层伪装。以这种方式接受惩罚，大概是最令人满意的结局。</p>
<p>东野大叔的确很擅长叙事，当看完全书再把前面的故事串起来时，才发现原来两位主角犯下了如此多的罪行，可谓千夫所指。这种人性的恶，在主人公身上被展现地淋漓尽致。</p>
<p>但整本书仅仅就是为了描述人性的恶吗？</p>
<p>关于整个故事，有一个颇具争议的问题：该不该同情雪穗和亮司？</p>
<p>我想，纵使不被同情，也不该把全部的错怪罪到他们身上。任何事情的发生都有个缘由。善恶终有来处。</p>
<p>出身贫苦，父亲早逝，与柔弱的母亲相依为命，被迫和陌生的大叔发生关系，这是唐泽雪穗的童年，也是导致其性格变化的直接原因。在那个破烂的潮湿的小屋子里，她度过了人生中本该最美好的一段时光，但留给她的却只有无尽的黑暗。母亲忙于生计，卑躬屈膝还要处处遭人白眼，连带着她一起受尽委屈。最可恨的是，为了生活，亲生母亲居然把她交易给胡子拉碴的大叔作为性工具，那是怎样一种无奈与痛苦。雪穗向母亲抗议过吗？我想大概是有的。但在母亲的恳求或是诱导下，她不得不接受这样的现实。从那一刻起，她的心里就已经埋下了邪恶的种子，随着时间的推移，慢慢生根发芽。</p>
<blockquote>
<p><strong>我从来就没有太阳，所以不怕失去。</strong></p>
</blockquote>
<p>正如她自已所说，她从一开始就是个身处黑暗的人，心中只剩欲望和仇恨。</p>
<p>桐原亮司的幼年也不快乐。虽然不愁吃穿，但风流成性的母亲和患有恋童癖的父亲显然没有给过他任何的关爱。他们不关心他每天都去了哪，干了啥，只管自己过得快活。他在家里没有任何人可以交流，于是他跑了出去，和同龄小朋友们玩耍是他少有的慰藉。直到他遇见了雪穗，他找到了一个可以说话的人，他把自己心爱的剪纸拿给她看，他和她经常相约在图书馆见面。多么美好的事啊，有这么可爱的玩伴。</p>
<p>他们本该这样长大。</p>
<p>当桐原拿起剪刀戳向父亲时，他一定花光了全部的力气。那种义无反顾，就像是去完成一件多么伟大的使命一般。只不过，此时的天空已被白夜笼罩。</p>
<p>从此枪虾和虾虎鱼开始了彼此依赖的生活。他们结伴而行，在白夜里摸索。</p>
<p>亮司最后强奸了美佳，变成了他父亲那样的人。雪穗安排了这一切，变成了她母亲那样的人。</p>
<p>这是小说中最具戏剧性的地方。受害者最终成为了害人者，新的受害人又是否会延续这样的轮回？循环往复，归途何处？</p>
<p>每当我们在报道里看到，一些青年乃至少年犯下的极恶罪行，总是会习惯性地感叹一番人心的险恶，家教的缺失，然后再将《未成年人保护法》痛骂一番。罪犯固然可恨，该受到应有的制裁，但我们更应该考虑到，扭曲的心灵并非与生俱来的，黑暗的背后更需要阳光的照耀。</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/baiyexing.png" alt="白夜行"></p>
<p>我曾认识这样一个女孩。</p>
<p>她出生在一个农村家庭，父亲嗜赌如命，在输光了家里所有的积蓄后，抛下她和母亲独自离去，那时她只有两岁半。母亲不堪重负，也狠心离去，将她留给了年迈的爷爷奶奶。村里的孩子经常欺负她，嘲笑她是个没人要的小孩，她很难过，又不知怎么反驳，就只是一味地哭。二老也没什么法子，就让她待在房间里，不准她出来。从此每天陪伴她的就只有洋娃娃和天花板，甚至连外面的蓝天白云都看不到。</p>
<p>后来她上了学，总是一个人坐在最角落的位置上，无心上课，成绩也一塌糊涂。后排调皮的男孩子经常拿她开玩笑，有的还动手动脚，她拼命想要反抗，但双拳难敌四手，她还是会经常受到欺负。终于有一天，她忍不住了，在放学路上捡起一块砖头狠狠扔向了其中一个人的头。</p>
<p>男孩受了重伤，家人找上门来，索要赔款，声称不赔钱就抓人。二老一边哭一边气，骂她是个没用的东西，和她爸一样，就知道干坏事。嘴上虽然骂娘，但钱还是得赔，总不能真让个十来岁的女娃子去蹲派出所。亲戚朋友们凑了点钱，把这事儿算是盖了过去。</p>
<p>后来倒也真平静了一阵儿，半年多没再闹事儿，估计是学校里的小伙儿们也心有戚戚，这姑娘惹不得。</p>
<p>那年春节，我爸妈觉得她家怪可怜的，又是街坊邻居的，就让我送点东西去她家。我把一篮子吃的提到厨房，和她奶奶聊了会儿家常。出门的时候，我不经意间回了个头，从旁边小房间里传来一道阴冷的光，差点没把我吓到。</p>
<p>她一个人蜷缩在房间的地板上，靠着床沿，边上是一台老旧的小彩电。她的目光朝我这边汇聚，眉头有一点点皱，紧咬着嘴唇，就那么死死地看着我。</p>
<p>我晃了晃神，匆忙地溜出大门，脚步飞快。</p>
<p>那是我一辈子忘不掉的眼神。</p>
<p>再后来，我去县城里上高中，少有机会回家，也就没再见到过她。只是某一年回去的时候听妈提起过，她好像很早就辍学了，离开了那个家，不知道去了哪。</p>
<p>天大地大，何处是家。</p>
<p>细想下这事儿，她的父亲肯定是要负首要责任的。父亲的恶习导致了家庭的破裂，给年幼的孩子造成了不可挽回的伤害。如果不想养家，又为何要成家？再往上找，父亲的恶习又是怎么造成的呢？大概是早年时不学无术，又没有一技之长，甚至懒惰地连活也不想干，于是就想找点快捷的方法。你说这该怪他的父母吗？可他们大概会说，我们要赚钱养家啊，哪有时间管孩子，只要他老老实实不给我们惹麻烦就行。他自己好赌，那是他天生的，这混账小子。</p>
<p>呵，养家糊口，不肖子孙，多么冠冕堂皇。</p>
<p>总有一些人，喜欢把孩子当做自己的附属品，只要给口饭吃给个衣服穿，就算是养他了。他们不懂得什么是教育，甚至不会教孩子基本的行为礼仪和道德廉耻，反正命是他的，爱咋咋地，老子当年也是这么过来的，不照样活得好好的？</p>
<p><strong>愚昧和无知，比黑暗本身更可怕</strong>。</p>
<p>想再讲个事儿。</p>
<p>近年来有个词在网络上出现的频率不断提升，就是“抑郁症”。</p>
<p>“某当红男星因抑郁症在家中服毒自杀，花样年华就此陨落。”</p>
<p>“某中学女生因难忍同学的流言蜚语，终日恍惚不定，最后留下一纸遗书，从十楼的家中跳下。”</p>
<p>伴随着抑郁症而出现的，还有一种叫做“网络暴力”的现象。某人被爆“黑料”，全网通告，好事者火速赶往现场，不论是非曲直，群起而攻之，或图一时之嘴快，或蹭一时之流量，他们坚信法不责众，大家都说黑的肯定错不了。当事人还未晃过神，就要迎接漫天的声讨。理智者顺藤摸瓜，找准源头，可使烟消云散。更多的人则选择沉默，听之任之，不到数日，或在沉默中爆发，或在沉默中消亡。前者伤人，后者伤身，只留下一声叹息，以供凭吊。</p>
<p>而我们，或许就曾是众多好事者中的一个，尽管有时连我们自己可能都没意识到。</p>
<p>少一点刽子手，多一点摸摸头。我们没办法要求别人如何如何，但至少自己能做到不轻信，不盲从，凡事有个理性的判断，而非人云亦云。毕竟，思维能力是人区别于动物的最大特点，如果连独立思考都不会了，又与动物何异呢？</p>
<p>愿白夜不再笼罩，黑夜里也能传来欢笑。</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 东野圭吾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Mac上搭建基于Hexo的个人博客网站]]></title>
      <url>/2017/10/29/create-hexo-blog/</url>
      <content type="html"><![CDATA[<p><strong>Hexo</strong>是一个快速、简洁且高效的博客框架，特别适合于部署静态的博客网站，更多介绍请移步<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener"><strong>官方文档</strong></a>。本文主要记录下笔者在<strong>Mac</strong>上实际的部署流程，包含期间遇到的坑和一些基本用法的介绍。</p>
<a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装<strong>Hexo</strong>前需要先安装<strong>Git</strong>和<strong>Node.js</strong></p>
<h3 id="1-Git"><a href="#1-Git" class="headerlink" title="1. Git"></a>1. Git</h3><p>在<strong>Mac</strong>上安装<strong>Git</strong>最方便的方式是使用<strong>Homebrew</strong>，它是<strong>Mac</strong>上的一种包管理工具，能方便地安装和卸载软件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure></p>
<p>安装结束后在命令行输入<strong>git</strong>后运行，如果屏幕上出现<strong>git</strong>命令的使用帮助，说明安装成功。</p>
<p>在后文中可以看到，笔者借助<strong>github</strong>的网站作为个人博客网站的代理服务器。在进行博客网站部署时，会频繁涉及到本地与<strong>github</strong>网站的通信，为了免去每次通信时都要输入用户名和密码的烦恼，我们可以将本地的一组<strong>ssh-key</strong>传到<strong>github</strong>网站上，作为通信的凭据。</p>
<p><strong>SSH</strong>是一种网络协议，全称<strong>Secure Shell</strong>，主要用于计算机之间的加密传输。以下介绍相应配置。</p>
<p>首先检查本地是否已存在<strong>ssh-keys</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a ~/.ssh/</span><br></pre></td></tr></table></figure></p>
<p>以上命令列出当前用户主目录下的<strong>.ssh</strong>目录中的所有文件，如果存在<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>则跳过下一步，否则需要手动生成一组<strong>ssh-key</strong></p>
<p>执行以下命令生成一组公/私钥，其中<strong>your_email@example.com</strong>需要替换成你自己的邮箱地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure></p>
<p>生成的文件默认会放在之前提到的<strong>.ssh</strong>目录中，我们需要获得公钥的值，在命令行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<p>该命令将公钥文件中的值，也就是一个很长的字符串输出到命令行中，复制该值备用。</p>
<p>接着登录<strong>github</strong>网站，单击右上角的头像，依次点击<code>Settings -&gt; SSH and GPG keys -&gt; New SSH key</code> 之后，会出现个文本框，在<code>Title</code>那一栏填写一些用于标识当前机器的信息，然后将前面复制的公钥值粘贴到<code>Key</code>那一栏，点击<code>Add SSH key</code>，即完成了添加操作，今后可以使用<code>ssh</code>地址直接从你的<strong>github</strong>仓库<code>clone</code>项目到本地，也可以将本地的修改直接<code>push</code>到<strong>github</strong>上，非常方便。</p>
<h3 id="2-Node-js"><a href="#2-Node-js" class="headerlink" title="2. Node.js"></a>2. Node.js</h3><p><strong>Node</strong>是<strong>javascript</strong>的一种运行时环境，也是近年来非常流行的一门技术。安装<strong>Node.js</strong>的最佳方式是使用<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。在命令行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash</span><br></pre></td></tr></table></figure></p>
<p>这条命令通过<strong>curl</strong>下载<strong>install.sh</strong>脚本，并执行脚本。待执行完成后，它会把<strong>nvm</strong>命令的执行路径放到<strong>~/.bashrc</strong>文件里，我们可以用<strong>cat</strong>命令来查看一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"/Users/gao-yimei/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; . <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br></pre></td></tr></table></figure></p>
<p>确认存在以上配置后，通过执行<strong>source</strong>命令来使得环境变量生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>至此我们就把<strong>nvm</strong>安装好了，可以通过以下命令查看<strong>nvm</strong>版本号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nvm --version</span><br><span class="line">0.29.0</span><br></pre></td></tr></table></figure></p>
<p>如果能正确打印出版本信息就证明<strong>nvm</strong>已经安装成功。接着通过执行以下命令来安装<strong>Node.js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure></p>
<p>如果安装期间遇到权限问题，可以改用<strong>sudo</strong>的方式重新运行。</p>
<p>安装完成后，在命令行键入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v7.1.0</span><br></pre></td></tr></table></figure></p>
<p>如果能够正确打印出版本信息，则说明安装成功。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>完成准备工作后，可以正式开始安装<strong>Hexo</strong>。在命令行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.npmjs.com" target="_blank" rel="noopener">npm</a>是<strong>Node.js</strong>自带的一个包管理工具，用于安装和卸载<strong>Node</strong>模块。上面的命令将<strong>Hexo</strong>这个模块以全局的方式安装到我们的电脑中，是<strong>Hexo</strong>官方推荐的方式。但笔者在运行这条命令时，出现了如下的错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! Error: EACCES: permission denied, mkdir <span class="string">'/usr/local/lib/node_modules/hexo-cli'</span></span><br><span class="line">npm ERR!     at Error (native)</span><br><span class="line">npm ERR!  &#123; [Error: EACCES: permission denied, mkdir <span class="string">'/usr/local/lib/node_modules/hexo-cli'</span>]</span><br><span class="line">npm ERR!   errno: -13,</span><br><span class="line">npm ERR!   code: <span class="string">'EACCES'</span>,</span><br><span class="line">npm ERR!   syscall: <span class="string">'mkdir'</span>,</span><br><span class="line">npm ERR!   path: <span class="string">'/usr/local/lib/node_modules/hexo-cli'</span>,</span><br><span class="line">npm ERR!   fstream_type: <span class="string">'Directory'</span>,</span><br><span class="line">npm ERR!   fstream_path: <span class="string">'/usr/local/lib/node_modules/hexo-cli'</span>,</span><br><span class="line">npm ERR!   fstream_class: <span class="string">'DirWriter'</span>,</span><br><span class="line">npm ERR!   fstream_stack: </span><br><span class="line">npm ERR!    [ <span class="string">'/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25'</span>,</span><br><span class="line">npm ERR!      <span class="string">'/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53'</span>,</span><br><span class="line">npm ERR!      <span class="string">'FSReqWrap.oncomplete (fs.js:82:15)'</span> ] &#125;</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Please try running this <span class="built_in">command</span> again as root/Administrator.</span><br></pre></td></tr></table></figure></p>
<p>明明是以<strong>sudo</strong>方式运行的啊，为什么会出现权限错误呢？笔者一头雾水，最后还是在某度上找到了一个解决方案。执行以下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure></p>
<p>大意就是忽略一些安全方面的警告，强制安装。最终成功安装上了。</p>
<h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>Hexo</strong>默认已经配置好了基本的选项，通过以下几步简单的操作就可以获得一个示例的博客网站。</p>
<p>终端切换到一个你准备用来搭建博客的目录，然后执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myblog</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>myblog</strong>将会作为博客网站的本地主目录，该命令对文件夹进行了初始化，生成了一些建设网站所必须的材料。切换到<strong>myblog</strong>文件夹下，执行以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>前面提到过，<strong>npm install</strong>是用来安装<strong>Node.js</strong>模块的，当这个命令不带参数时，它将会读取当前目录(也就是<strong>myblog</strong>目录)下的<strong>package.json</strong>文件，并按照里面的描述来安装，所有的模块都会存在当前目录下一个名为<strong>node_modules</strong>的文件夹下。</p>
<p>等待安装完成后，仍在当前目录下，执行以下命令，开启<strong>Hexo</strong>服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo start</span><br></pre></td></tr></table></figure></p>
<p>若一切正常，则命令行会打印出如下的提示信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>
<p>该信息表示<strong>Hexo</strong>服务器已经在本地的<strong>4000</strong>端口运行了。打开任意浏览器，在地址栏输入<strong>localhost:4000</strong>后回车，即可看到默认的欢迎页面。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>默认页面上信息都是关于<strong>Hexo</strong>的，我们要将其改为自己的信息。在<strong>myblog</strong>目录下，使用<strong>ls</strong>命令查看该目录下的所有文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">_config.yml     node_modules    package.json    scaffolds   themes  db.json     package-lock.json   public      <span class="built_in">source</span>      yarn.lock</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>_config.yml</strong>保存了与网站相关的基本配置。使用<strong>vim</strong>打开，可以看到如下信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 你的博客名称</span><br><span class="line">subtitle:</span><br><span class="line">description: 你的博客介绍或者座右铭</span><br><span class="line">author: 你的昵称</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>最开始的部分就是关于网站的标题、作者和简介等信息，这里可以根据个人的情况填写，其中<strong>language</strong>那一栏填写<strong>zh-Hans</strong>表示网站采用简体中文。<strong>填写时注意各个字段的冒号后必须要空一格再填具体内容</strong>，填写完毕后保存即可。</p>
<p>接着我们来看一下<strong>Hexo</strong>中一项很实用也很强大的工具，那就是<strong>主题</strong>。大家之所以喜欢写个人博客，一个很重要的原因就是它的自由性，我们可以往博客上添加任何个人喜欢的元素，也可以根据自己的喜好来定制网站的背景、样式、配色等。<strong>Hexo</strong>为我们修改网站的风格提供了一种非常便捷的方法，只需要简单的几步，就可以将我们的网站修改成一种指定的风格，我们还可以自己定制喜欢的模板。下面以<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>上提供的<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>主题为例，介绍下如何为我们的博客更换不同的主题。</p>
<p>在<strong>myblog</strong>目录下执行以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p><strong>Hexo</strong>中的主题实际上都是由不同的网友贡献的，以上命令将该主题所对应的<strong>github</strong>上的项目克隆到<strong>myblog</strong>目录的<strong>themes</strong>目录下。</p>
<p>接着打开<strong>myblog</strong>目录下的<strong>_config.yml</strong>文件，找到<strong>theme</strong>配置项，将对应的值改成<strong>next</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<p>保存后退出。仍在<strong>myblog</strong>目录下，依次执行以下指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean    </span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>两条命令分别是清除缓存文件以及重新生成静态文件。重新启动<strong>Hexo</strong>服务，即可看到<strong>next</strong>主题风格的博客页面。</p>
<h3 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h3><h4 id="添加个人头像"><a href="#添加个人头像" class="headerlink" title="添加个人头像"></a>添加个人头像</h4><p>有了主题之后，我们可以在网站中设置侧边栏个人头像。在<strong>myblog</strong>目录下，打开<strong>themes/next/_config.yml</strong>文件，找到<strong>avatar</strong>配置项，将值设为头像的地址。该地址可以是一个完整的图片链接，也可以是一个站点内的相对路径。如果使用前者，为了保证图片链接的有效性，可以先将图片上传到<strong>github</strong>上再使用对应链接，而对于后者，则需要先将图片放到<strong>themes/next/source/images</strong>目录下，再使用相对路径引用。以下配置是一个采用相对路径的示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">avatar: /images/coolboy.jpg</span><br></pre></td></tr></table></figure></p>
<h4 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h4><p><strong>Hexo</strong>默认只开启了两个标签：首页和归档，我们可以添加一些常用的其他标签，比如标签、分类和关于。先打开<strong>/themes/next/_config.yml</strong>文件，找到<strong>menu</strong>配置项，如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line">menu_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br></pre></td></tr></table></figure></p>
<p>可以看到默认情况下只有<strong>home</strong>和<strong>archives</strong>前面没有<strong>#</strong>号，其他项都没注释掉了，因此我们要先把准备开启的标签前的<strong>#</strong>号给去掉，并且在下方<strong>menu_icons</strong>配置相应的值，这里配置的<strong>icon</strong>也就是网页上展现的对应的图标，实际上是由<a href="http://fontawesome.io" target="_blank" rel="noopener">Font Awesomo</a>网站提供的，涵盖了众多常用的网站图标。配好之后保存退出。</p>
<p>然后我们来创建需要的页面。首先是<strong>about</strong>页面，在<strong>myblog</strong>目录下运行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"about"</span></span><br></pre></td></tr></table></figure></p>
<p>这条命令会在<strong>source</strong>目录下新建一个名为<strong>about</strong>的文件夹，并生成一个<strong>index.md</strong>文件，使用任意的<strong>markdown</strong>编辑器打开后编辑，可以写上个人的介绍以及一些自己想说的话，完成后保存退出，这样一来<strong>about</strong>页面就做好了。</p>
<p>接下来是<strong>categories</strong>页面，同理，先在命令行运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></p>
<p>然后编辑刚刚创建的<strong>index.md</strong>文档，将页面类型设置为<strong>categories</strong>即可，Hexo会自动将带有不同类别标签的文章进行分类归档展示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line">date: 2017-10-27 17:27:06</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>这里还有个<strong>comments</strong>字段被设置为<strong>false</strong>，这是因为<strong>Hexo</strong>的博客可以外接一些第三方的评论系统，默认在所有页面都会显示，而我们一般只希望评论显示在文章主页面的下方，因此此处将评论给关闭。</p>
<p>最后是<strong>tags</strong>页面，同理先在命令行创建页面，然后编辑页面，将页面的类型设置为<strong>tags</strong>即可，<strong>Hexo</strong>的主题系统会自动地在这个页面中显示标签云<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="添加Read-More按钮"><a href="#添加Read-More按钮" class="headerlink" title="添加Read More按钮"></a>添加Read More按钮</h4><p>默认情况下我们的文章会在主页以全部展开的形式呈现，但我们通常希望在主页上每篇文章只显示一部分，这样既显得简洁，又可能让读者看到更多的文章，便于读者的判断。想要做到这一点很简单，只要在文章对应的<strong>markdown</strong>文档中，按照下图所示插入一句特殊的代码到我们想要进行截断的任意位置即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">More info: [Server](https://hexo.io/docs/server.html)</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Generate static files</span></span><br></pre></td></tr></table></figure></p>
<p>这样首页上的文章只会显示之前的部分，然后会有一个<strong>阅读全文</strong>的按钮，点击之后再进入文章的主页面，看起来非常舒服，也很合理。</p>
<p>经过上面的这些设置后，我们就能得到一个看起来不错的博客网站了，可以运行<strong>Hexo</strong>服务，在浏览器上实时查看我们的网站，现在的情况就像这样</p>
<p><img src="https://raw.githubusercontent.com/coolBoyGym/images/master/hexo/01.png" alt="blog-first-site"></p>
<h2 id="通过github发布"><a href="#通过github发布" class="headerlink" title="通过github发布"></a>通过github发布</h2><p>现在我们已在把网站在本地搭起来了，为了让别人能通过互联网访问我们的网站，还需要将其发布到网络上，这里我们以发布到<strong>github</strong>上为例。</p>
<p>首先，我们要在<strong>github</strong>上新建一个<strong>Repository</strong>，名称固定为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yourNickName.github.io</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>yourNickName</strong>指的是你的<strong>github</strong>账户昵称，注意必须按照这个规则来命名。然后我们编辑<strong>myblog/_config.yml</strong>文件，在文件的最后几行找到<strong>deploy</strong>设置项，按照下面的方式进行修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:coolBoyGym/coolboygym.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>其中的<strong>repository</strong>字段需改成你自己的<strong>giuhub</strong>项目对应的地址。</p>
<p>修改完成后，在<strong>blog</strong>目录下依次运行以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p><strong>Hexo</strong>会先在本地生成静态的网页文件，然后将所有文件推送到<strong>github</strong>上对应的项目中。一切正常的话，我们就可以通过下面的网址访问个人博客，应该能看到和本地一样的效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://yourNickName.github.io</span><br></pre></td></tr></table></figure></p>
<p>到此，我们就算是真的搭建好一个简单的博客网站了，赶快请你的小伙伴们来看看吧~</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>当我们想要写一篇新博客时，先执行以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My-New-Post"</span></span><br></pre></td></tr></table></figure></p>
<p>其中<strong>My-New-Post</strong>是你想新建的博文的名字，这条指令会在<strong>myblog/source/_posts</strong>文件夹下新建一个名为<strong>My-New-Post.md</strong>的文件，我们可以使用任意的<strong>markdown</strong>编辑器来打开它进行编写，完成之后，我们可以先在本地查看下效果，确认无误后，同样通过之前的两条命令来将这篇新的博文发布到<strong>github</strong>上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>关于<strong>markdown</strong>编辑器，笔者使用的是<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown</a>，界面比较简洁，可预览，功能也较全，值得推荐~</p>
<p>以上就是本文的全部内容，涉及到了<strong>Hexo</strong>的一些基本操作，当然它的强大还远不止于此，通过集成各种第三方的服务，可以让我们的网站变得更加有趣，这个就有待读者们自己探究了，有什么好玩的第三方工具欢迎告诉我。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<ul>
<li><a href="http://gonghonglou.com/2016/02/03/firstblog/" target="_blank" rel="noopener">与佳期的个人博客</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="noopener">github/iissnan</a></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/28/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> daily </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
